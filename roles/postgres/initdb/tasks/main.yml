---

# Â© Copyright EnterpriseDB UK Limited 2015-2021 - All rights reserved.

- name: Include pre-initdb hook
  include_tasks: "{{ hook }}"
  when:
    lookup('first_found', dict(files=hook, skip=True))
  vars:
    hook: "{{ cluster_dir }}/hooks/pre-initdb.yml"
  tags: always

- name: Ensure postgres directories exist and have the right permissions
  file:
    path: "{{ item }}"
    owner: "{{ postgres_user }}"
    group: "{{ postgres_group }}"
    mode: 0700
    state: directory
  with_items:
    - "{{ postgres_home }}"
    - "{{ postgres_data_dir }}"
    - "{{ postgres_wal_dir if (postgres_wal_dir is defined and postgres_wal_dir|dirname != postgres_data_dir) else [] }}"
    - "{{ postgres_conf_dir if postgres_conf_dir != postgres_data_dir else [] }}"

# https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SELinux_Users_and_Administrators_Guide/sect-Managing_Confined_Services-PostgreSQL-Configuration_Examples.html

- name: Set correct SELinux context for {{ postgres_data_dir }}
  shell: >
    if $(type -p selinuxenabled); then
    semanage fcontext -a -t postgresql_db_t "{{ postgres_data_dir }}(/.*)?" &>/dev/null;
    restorecon -R -v "{{ postgres_data_dir }}"|wc -l;
    fi
  args:
    executable: /bin/bash
  register: restorecon
  failed_when:
    restorecon is not successful
  changed_when: >
    restorecon.stdout.strip() not in ['', '0']
  when:
    postgres_data_dir != default_postgres_data_dirs[ansible_os_family] and
    platform not in ['docker']

- name: Set correct SELinux context for {{ postgres_conf_dir }}
  shell: >
    if $(type -p selinuxenabled); then
    semanage fcontext -a -t postgresql_db_t "{{ postgres_conf_dir }}(/.*)?" &>/dev/null;
    restorecon -R -v "{{ postgres_conf_dir }}"|wc -l;
    fi
  args:
    executable: /bin/bash
  register: restorecon
  failed_when:
    restorecon is not successful
  changed_when: >
    restorecon.stdout.strip() not in ['', '0']
  when:
    postgres_conf_dir != postgres_data_dir
    and platform not in ['docker']

- name: Set correct SELinux context for postgres_wal_dir, if set
  shell: >
    if $(type -p selinuxenabled); then
    semanage fcontext -a -t postgresql_db_t "{{ postgres_wal_dir }}(/.*)?" &>/dev/null;
    restorecon -R -v "{{ postgres_wal_dir }}"|wc -l;
    fi
  args:
    executable: /bin/bash
  register: restorecon
  failed_when:
    restorecon is not successful
  changed_when: >
    restorecon.stdout.strip() not in ['', '0']
  when:
    - postgres_wal_dir is defined
    - postgres_wal_dir|dirname != postgres_data_dir
    - platform not in ['docker']

# Even if PGDATA was not initialised when we ran minimal_postgres_setup
# from init, we may now have a valid PGDATA now after mounting a volume
# or doing something in the pre-initdb hook. Therefore we must re-check
# whether pgdata_initialised should be set.

- name: Recheck pgdata_initialised
  minimal_postgres_setup:
    pgdata: "{{ postgres_data_dir }}"

- name: Add postgres_wal_dir to initdb options if set
  set_fact:
    postgres_initdb_opts: "{{ postgres_initdb_opts + ['--waldir=' + postgres_wal_dir] }}"
  when:
    - postgres_wal_dir is defined
    - postgres_wal_dir|dirname != postgres_data_dir

- name: Initialise PGDATA={{ postgres_data_dir }}
  block:
    - name: Run initdb to initialise data directory
      command: >
        {{ postgres_bin_dir }}/initdb -D {{ postgres_data_dir }} \
          {% for x in postgres_initdb_opts %}{{ x|quote }} {% endfor %}
      vars:
        _task_environment:
          TZ: UTC
          LC_ALL: "{{ postgres_locale }}"
      environment: "{{ target_environment|combine(_task_environment) }}"
      become_user: "{{ postgres_user }}"
      become: yes

    - name: Move configuration files to {{ postgres_conf_dir }}
      command: >
        mv "{{ postgres_data_dir }}/{{ item.value }}"
           "{{ postgres_conf_dir }}/{{ item.value }}"
      args:
        creates: "{{ postgres_conf_dir }}/{{ item.value }}"
      with_dict: "{{ postgres_conf_files }}"
      when:
        postgres_conf_dir != postgres_data_dir
      changed_when: True

    - set_fact: pgdata_initialised=True
  when:
    not pgdata_initialised and 'replica' not in role
