---

# Â© Copyright EnterpriseDB UK Limited 2015-2023 - All rights reserved.

# We must perform an in-place major-version upgrade of Postgres and BDR
# on a running cluster while maintaining overall cluster availability.
#
# The cluster may comprise BDR primary, logical standby, and physical
# streaming replica instances; and pgbouncer+haproxy instances besides.
# Logical standby and physical replica instances can be upgraded without
# any special precautions. Just stop, upgrade, start.
#
# For BDR primaries, we must first check if haproxy is routing traffic
# to them, and if so, redirect to another primary before stopping and
# upgrading this one.
#
# We try to minimise the downtime on each instance by downloading
# the packages before stopping the server.
# 
# At this time, the data directory of the previous version of Postgres
# is not removed by this script post-upgrade.

- name: Install procps if missing (RedHat only)
  package:
    name: procps-ng
    state: present
  when: >
    ansible_os_family == 'RedHat'

- set_fact:
    old_postgres_version: "{{ cluster_facts.postgres_version }}"
    old_postgres_data_dir: "{{ cluster_facts.postgres_data_dir }}"
    old_postgres_bin_dir: "{{ cluster_facts.postgres_bin_dir }}"
    new_postgres_version: "{{ postgres_version }}"
    new_postgres_data_dir: "{{ postgres_data_dir }}"
    new_postgres_bin_dir: "{{ postgres_bin_dir }}"
    upgrade_port: 50432

- set_fact:
    upgrade_dsn: "port={{ upgrade_port }}"

- name: Skip this node if already upgraded and running
  shell: |
    ps -ef | grep {{ new_postgres_data_dir }} | grep -v grep | wc -l
  register: upgraded_postgres_running

- set_fact:
    upgraded_postgres_running: "{{ upgraded_postgres_running.stdout|int > 0 }}"
    already_upgraded: "{{ upgraded_postgres_running }}"

- name: If Postgres is down, we may have already upgraded; so compare the service PGDATA to the config PGDATA for this node
  block:
  - name: Get Service Status
    systemd:
      name: postgres
    register: pg_service_status

  - set_fact:
      service_pgdata: "{{ pg_service_status.status.Environment.split(' ')|select('match', 'PGDATA')|first|split('=')|last }}"

  - shell:
      cat {{ service_pgdata }}/PG_VERSION
    register: service_pgversion

  - set_fact:
      service_pgversion: "{{ service_pgversion.stdout|int }}"

  - set_fact:
      already_upgraded: "{{ new_postgres_version is version(service_pgversion, 'eq') }}"
  when: >
    not upgraded_postgres_running

- name: Review system state
  block: 
  - name: Get Server Status
    shell: |
      ps -ef | grep {{ service_pgdata }} | grep -v grep | wc -l
    register: old_postgres_running

  - set_fact:
      old_postgres_running: "{{ old_postgres_running.stdout|int > 0 }}"

  - assert:
      that: "{{ pg_service_status.status.ActiveState == 'active' or old_postgres_running }}"
      msg: "FAILED: the old Postgres instance must be running, exiting."

  - set_fact:
      old_postgres_data_dir: "{{ service_pgdata }}"

  - name: Find old PGVERSION (and can we connect w/o issue)
    postgresql_query:
      conninfo: "{{ dsn|dbname('postgres') }}"
      query: SELECT current_setting('server_version') AS version
    register: old_postgres_version
    become: yes
    become_user: "{{ postgres_user }}"

  - set_fact:
      old_postgres_version: "{{ old_postgres_version.results[0].version.split('.')[0] }}"

  - assert:
      that: "{{ old_postgres_version is version('11', 'ge') }}"
      msg: "FAILED: the old Postgres version must be at least version 11, exiting."

  - assert:
      that: "{{ new_postgres_version is version(old_postgres_version, 'gt') }}"
      msg: "FAILED: the new Postgres version must be higher than the old Postgres version, exiting."

  - assert:
      that: "{{ new_postgres_version is version(old_postgres_version|int + 1, 'eq') }}"
      msg: "FAILED: the new Postgres version must be only one major version higher than the old Postgres version, exiting."
    when: new_postgres_version is version(old_postgres_version, 'ne') 

  - debug:
      msg: "Skipping major upgrade of {{ inventory_hostname }}; the running instance is already version {{ new_postgres_version }}."
    when: new_postgres_version is version(old_postgres_version, 'eq') 
 
  - name: Stop harp-manager on {{ inventory_hostname }}
    systemd:
      name: harp-manager
      state: stopped
    when: >
      ('bdr' in role 
       and failover_manager == 'harp'
       and inventory_hostname in first_bdr_primary_candidates)

  - name: Download and install Postgres {{ new_postgres_version }}
    block:
    - name: Remove BDR debug packages (conflict issue)
      package:
        name: "edb-bdr{{ bdr_version }}-{{ postgresql_flavour }}{{ old_postgres_version }}-debuginfo*"
        state: absent
      vars:
        _ansible_python_interpreter: /usr/bin/python2
      when: >
        'bdr' in role and postgresql_flavour == 'epas'

    - name: Stop the old instance
      systemd:
        name: postgres
        state: stopped
        masked: true

    - include_role: name=sys/repositories

    - include_role: 
        name: postgres
        apply:
          tags: [pkg, src, initdb]
      tags: [pkg, src, initdb]

    - block:
        - block:
            - include_role: name=repmgr/pkg
            - copy:
                remote_src: yes
                src: "{{ old_repmgr_conf_file }}"
                dest: "{{ new_repmgr_conf_file }}"

            - name: Replace paths in copy of repmgr.conf
              replace:
                path: "{{ new_repmgr_conf_file }}"
                regexp: "{{ item.value.old_path }}"
                replace: "{{ item.value.new_path }}"
              loop: "{{ _conf_dirs|dict2items }}"
          when:
            failover_manager == 'repmgr'

        # TBD same as above, copy efm.properties and update for paths of new instance
        - include_role: name=efm/pkg
          when: >
            'efm' in role
      vars:
        _conf_dirs:
          bin:
            old_path: 
              "{{ old_postgres_bin_dir }}"
            new_path: 
              "{{ new_postgres_bin_dir }}"
          data:
            old_path: 
              "{{ old_postgres_data_dir }}"
            new_path: 
              "{{ new_postgres_data_dir }}"
          repmgr:
            old_path: 
              "{{ old_repmgr_conf_dir }}"
            new_path: 
              "{{ new_repmgr_conf_dir }}"
        new_repmgr_conf_dir: "{{ repmgr_conf_dir }}"
        new_repmgr_conf_file: "{{ repmgr_conf_file }}"
        old_repmgr_conf_dir: "{{ old_repmgr_conf_file|dirname }}"
        old_repmgr_conf_file: "{{ cluster_facts.repmgr.nodes
                                  |selectattr('node_name','eq', inventory_hostname)
                                  |list
                                  |map(attribute='config_file')
                                  |first }}"
      when:
        failover_manager in ['repmgr', 'efm']

- name: De-register PEM agent
  block:
  - include_role: # need pem_agent_config_path and pem_agent_certificate_directory provided by this role
      name: pem/agent/config/final
      public: yes
      apply:
        when: false

  - import_role: # need pem_postgres_password provided by this role
      name: pem/final

  - command: >
      {{ pem_agent_base_dir }}/bin/pemworker --unregister-server  \
        --pem-user "{{ hostvars[pem_server].postgres_user }}"     \
        --server-addr "{{ inventory_hostname }}"                  \
        --server-port "{{ postgres_port }}"                       \
        --config-dir "{{ pem_agent_config_path|dirname }}"
    environment: "{{ target_environment|combine(_task_environment) }}"
    vars:
      _task_environment:
        PEM_SERVER_PASSWORD: "{{ pem_postgres_password }}"
        PEM_MONITORED_SERVER_PASSWORD: "{{ vars['%s_password' % postgres_user] }}"
    register: deregister_server_cmd
    no_log: false

  - debug:
      msg: "{{ deregister_server_cmd.stdout }}"

  - name: Stopping PEM agent (may take a while)
    service:
      name: pemagent
      state: stopped

  - file:
      path: "{{ pem_agent_config_path }}"
      state: absent

  when: >
    'pem-agent' in role
  ignore_errors: true

- name: Prepare to upgrade {{ inventory_hostname }} to Postgres {{ new_postgres_version }}
  block:
  - name: Start new instance
    shell: |
      {{ new_postgres_bin_dir }}/pg_ctl start -D {{ new_postgres_data_dir }}
    become: yes
    become_user: "{{ postgres_user }}"

  - include_role: 
      name: postgres/config
    vars:
      pgdata_initialised: false
      postgres_port: "{{ upgrade_port }}"
      dsn: "{{ upgrade_dsn }}"
      postgres_dsn: "port={{ upgrade_port }} dbname=postgres"          

  - name: Update shared_preload_libraries in TPA restart-only configuration file
    lineinfile:
      path: "{{ new_postgres_data_dir }}/conf.d/0001-tpa_restart.conf"
      regexp: '^shared_preload_libraries.*$'
      line: |
        shared_preload_libraries = '{{ shared_preload_libraries|join(', ') }}'

  - name: Restart the new instance for some settings to take effect
    shell: |
      {{ new_postgres_bin_dir }}/pg_ctl restart -D {{ new_postgres_data_dir }} -o "-F -p {{ upgrade_port }}"
    become: yes
    become_user: "{{ postgres_user }}"

  - name: Change Postgres port for the new instance to match the old instance
    postgresql_query:
      autocommit: yes
      conninfo: "{{ upgrade_dsn|dbname('postgres') }}"
      queries:
        - text: ALTER SYSTEM SET port = %s
          args:
            - "{{ postgres_port }}"
    become: yes
    become_user: "{{ postgres_user }}"

  - name: Collect all unnecessary Postgres roles in the new instance to be dropped
    postgresql_query:
      conninfo: "{{ upgrade_dsn|dbname('postgres') }}"
      queries: 
        - text:
            SELECT rolname
            FROM   pg_roles
            WHERE  rolname NOT IN (%s,'aq_administrator_role')
               AND rolname NOT LIKE 'pg_%%'
          args:
            - "{{ postgres_user }}"
    become: yes
    become_user: "{{ postgres_user }}"
    register: granted_roles

  - name: Drop all unnecessary Postgres roles from the new instance
    postgresql_query:
      conninfo: "{{ upgrade_dsn|dbname('postgres') }}"
      query: "DROP ROLE {{ item.rolname }}"
    become: yes
    become_user: "{{ postgres_user }}"
    with_items:
      "{{ granted_roles.results }}"
    ignore_errors: yes

  - name: Change Postgres port for the new instance to match the old instance
    postgresql_query:
      autocommit: yes
      conninfo: "{{ upgrade_dsn|dbname('postgres') }}"
      queries:
        - text: ALTER SYSTEM SET port = %s
          args:
            - "{{ postgres_port }}"
    become: yes
    become_user: "{{ postgres_user }}"

  - name: Start the old instance
    systemd:
      name: postgres
      state: started
      masked: false

  - name: Stop the new instance
    shell: |
      {{ new_postgres_bin_dir }}/pg_ctl stop -D {{ new_postgres_data_dir }}
    become: yes
    become_user: "{{ postgres_user }}"

  - name: Drop pg_catalog.pgbouncer_get_auth from the old instance to facilitate the upgrade
    postgresql_query:
      conninfo: "{{ dsn|dbname(item) }}"
      query: DROP FUNCTION IF EXISTS pg_catalog.pgbouncer_get_auth
    become: yes
    become_user: "{{ postgres_user }}"
    with_items: "{{ cluster_facts.databases.keys()|list }}"
    when: > 
      item not in ['template0', 'bdr_supervisordb'] and 'readonly' not in role and 'primary' not in role

  - name: Does the BDR schema exist? 
    postgresql_query:
      conninfo: "{{ dsn|dbname(bdr_database) }}"
      query: >
        SELECT 'OK' FROM pg_namespace WHERE nspname='bdr'
    become_user: "{{ postgres_user }}"
    become: yes
    register: bdr_schema_found
    when: >
     'bdr' in role

  - set_fact:
      bdr_schema_found: "{{ false if bdr_schema_found is skipped else bdr_schema_found.rowcount == 1|bool }}" 

  - name: Perform major Postgres upgrade to version {{ new_postgres_version }}
    block:
    - file:
        path: "{{ new_postgres_data_dir }}/upgrade_logs"
        state: directory
      become: yes
      become_user: "{{ postgres_user }}"
  
    - block:
      - name: Run bdr_pg_upgrade on {{ inventory_hostname }}
        shell:
          cmd: "/usr/bin/bdr_pg_upgrade --database {{ bdr_database }}"
          chdir: "{{ new_postgres_data_dir }}/upgrade_logs"
        environment: "{{ _task_environment }}"
        vars:
          _task_environment:
            PGBINOLD: "{{ old_postgres_bin_dir }}"
            PGBINNEW: "{{ new_postgres_bin_dir }}"
            PGDATAOLD: "{{ old_postgres_data_dir }}"
            PGDATANEW: "{{ new_postgres_data_dir }}"
            PGPORTOLD: "{{ postgres_port }}"
            PGSOCKETDIR: /tmp
        register: pg_upgrade_result
        become: yes
        become_user: "{{ postgres_user }}"
        ignore_errors: yes
  
      - name: Get upgrade results
        set_fact:
          upgrade_result: "{{ pg_upgrade_result }}"
        when: >
          pg_upgrade_result is not skipped
  
      when: >
        'bdr' in role and bdr_schema_found
  
    - debug:
        msg: "{{ upgrade_result }}"
      when:
        upgrade_result is defined
  
    - block:
      - postgresql_query:
          conninfo: "{{ dsn|dbname(bdr_database) }}"
          query: >
            DROP EXTENSION bdr CASCADE;
        become: yes
        become_user: "{{ postgres_user }}"
        when: >
          'bdr' not in role and bdr_schema_found
        ignore_errors: yes
 
      - systemd:
          name: postgres
          state: stopped
 
      - name: Run pg_upgrade on {{ inventory_host }}
        shell:
          cmd: "{{ new_postgres_bin_dir }}/pg_upgrade --link"
          chdir: "{{ new_postgres_data_dir }}/upgrade_logs"
        environment: "{{ _task_environment }}"
        vars:
          _task_environment:
            PGBINOLD: "{{ old_postgres_bin_dir }}"
            PGBINNEW: "{{ new_postgres_bin_dir }}"
            PGDATAOLD: "{{ old_postgres_data_dir }}"
            PGDATANEW: "{{ new_postgres_data_dir }}"
            PGPORTOLD: "{{ postgres_port }}"
            PGSOCKETDIR: /tmp
        register: pg_upgrade_result
        become: yes
        become_user: "{{ postgres_user }}"
        ignore_errors: yes
  
      - name: Get upgrade results
        set_fact:
          upgrade_result: "{{ pg_upgrade_result }}"
        when: >
          pg_upgrade_result is not skipped
  
      when: >
         'bdr' not in role or ('bdr' in role and not bdr_schema_found)
  
    - find:
        paths: "{{ new_postgres_data_dir }}/upgrade_logs"
        patterns: '*'
      register: upgrade_logs
  
    - name: Get upgrade logs from {{ inventory_hostname }}
      fetch:
        src: "{{ item.path }}"
        dest: "{{ cluster_dir }}/upgrade_logs/{{ inventory_hostname }}/"
        flat: yes
      with_items:
        - "{{ upgrade_logs.files }}"
      become: yes
      become_user: "{{ postgres_user }}"    
  
    - block:
      - debug:
          msg: "{{ upgrade_result.stdout_lines }}" 
  
      - assert:
          that: "{{ upgrade_result.rc == 0 }}"
          msg: "Upgrade FAILED, see logs in {{ cluster_dir }}/upgrade_logs/{{ inventory_hostname }}"
      when: >
        upgrade_result is defined

  when: >
    not already_upgraded and 'replica' not in role

