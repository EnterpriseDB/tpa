---

# Â© Copyright EnterpriseDB UK Limited 2015-2022 - All rights reserved.

# First, we ensure that the users in postgres_users exist and have the
# desired attributes and passwords.
#
# The entries in postgres_users may be specified in config.yml, or come
# from invocations of postgres/createuser by other roles in TPAexec (to
# create, for example, the users required by repmgr or barman).
#
# postgres_users:
# - username: xyzzy
#   generate_password: true
#   role_attrs:
#   - superuser
#   - replication
#
# If an entry in postgres_users specifies `generate_password: false`, we
# neither generate nor set a password for that user. Otherwise, we must
# generate passwords for any entries for which postgres/createuser has
# not already generated one.

- name: Generate missing passwords
  include_role: name=secret
  vars:
    secret_name: "{{ item.username }}_password"
  with_items: "{{ postgres_users }}"
  when:
    secret_name not in vars
    and item.generate_password|default(true)

# After the required passwords are generated, we can create users with a
# password encrypted according to the entry's `password_encryption`, or
# the Postgres default setting.
#
# We act on `granted_roles` for each user only after creating extensions
# below, because some of the roles we want to grant may not exist until
# then (e.g., bdr_application).

- name: Create Postgres users
  postgresql_user:
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    login_db: postgres
    name: "{{ item.username }}"
    password: "{{
      encrypted_password if generated_password is defined else omit
    }}"
    encrypted: yes
    role_attr_flags: "{{
      item.role_attrs|default([])|join(',') or omit
    }}"
  vars:
    secret_name: >-
      {{ item.username }}_password
    generated_password: >-
      {{ vars.get(secret_name) }}
    existing_password: >-
      {{ cluster_facts.roles[item.username].rolpassword|default('unknown') }}
    encrypted_password: "{{
      item.password_encryption|default(password_encryption)|encrypted_password(
        generated_password, item.username, existing_password=existing_password
      )
    }}"
  with_items: "{{ postgres_users }}"
  become_user: "{{ postgres_user }}"
  become: yes

# Now we issue a CREATE EXTENSION command for each extension in
# `postgres_extensions`, in the postgres and template1 databases.

- name: Install default Postgres extensions
  postgresql_ext:
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    state: present
    db: "{{ item.0 }}"
    name: "{{ item.1 }}"
  with_nested:
    - [postgres, template1]
    - "{{ postgres_extensions }}"
  become_user: "{{ postgres_user }}"
  become: yes
  when:
    item.1 not in cluster_facts.databases[item.0].extensions|default({})

# Now we issue CREATE TABLESPACE for each entry in postgres_tablespaces.
# (We create tablespaces before databases because postgres_databases may
# specify a default tablespace for a database.)

- name: Create Postgres tablespaces
  postgresql_tablespace:
    name: "{{ item.key }}"
    owner: "{{ postgres_user }}"
    location: "{{ item.value.location }}"
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    state: "{{ item.value.state|default('present') }}"
    db: postgres
  with_dict: "{{ postgres_tablespaces|default({}) }}"
  loop_control:
    label: >-
      {{ item.key }}
  become_user: "{{ postgres_user }}"
  become: yes

# Now that all required roles and tablespaces exist, we can create the
# databases specified in postgres_databases with the correct owners and
# default tablespaces.
#
# If you do not want to inherit postgres_extensions from template1 (the
# default template database), set `template: template0` explicitly and
# set extensions in postgres_databases (to be created below).

- name: Create Postgres databases
  postgresql_db:
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    maintenance_db: postgres
    name: "{{ db.name }}"
    owner: "{{ db.owner|default(omit) }}"
    encoding: "{{ db.encoding|default(omit) }}"
    lc_collate: "{{ db.lc_collate|default(omit) }}"
    lc_ctype: "{{ db.lc_ctype|default(omit) }}"
    template: "{{ db.template|default(omit) }}"
    tablespace: "{{ db.tablespace|default(omit) }}"
    state: "{{ db.state|default('present') }}"
  with_items: "{{ postgres_databases }}"
  loop_control:
    loop_var: db
    label: >-
      {{ db.name }}
  become_user: "{{ postgres_user }}"
  become: yes

# Apart from the extensions we create in template1 (which are inherited
# by every other database), each entry in postgres_databases can also
# specify a list of extensions to create in only that database.

- name: Create extensions in each database
  postgresql_ext:
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    db: "{{ item.0.name }}"
    name: "{{ item.1.name }}"
    state: "{{ item.1.state|default('present') }}"
    schema: "{{ item.1.schema|default(omit) }}"
    cascade: "{{ item.1.cascade|default(omit) }}"
    session_role: "{{ item.1.session_role|default(omit) }}"
  with_nested_dependents:
    - postgres_databases
    - item.0.get("extensions", [])
  loop_control:
    label: >-
      {{ item.0.name }}/{{ item.1.name }}
  become_user: "{{ postgres_user }}"
  become: yes

# We do likewise for any languages listed in postgres_databases. This
# just issues "CREATE LANGUAGE" commands; if any packages are required,
# they must already be installed, e.g., through extra_postgres_packages.

- name: Create languages in each database
  postgresql_lang:
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    db: "{{ item.0.name }}"
    name: "{{ item.1.name }}"
    trust: "{{ item.1.trust|default(omit) }}"
    state: "{{ item.1.state|default('present') }}"
    cascade: "{{ item.1.cascade|default(omit) }}"
    session_role: "{{ item.1.session_role|default(omit) }}"
    fail_on_drop: "{{ item.1.fail_on_drop|default(omit) }}"
  with_nested_dependents:
    - postgres_databases
    - item.0.get("languages", [])
  loop_control:
    label: >-
      {{ item.0.name }}/{{ item.1.name }}
  become_user: "{{ postgres_user }}"
  become: yes

# Now we can complete the task of granting roles to `postgres_users`.

- name: Grant roles to Postgres users if required
  postgresql_membership:
    port: "{{ postgres_port }}"
    login_user: "{{ postgres_user }}"
    login_db: postgres
    groups: "{{ item.granted_roles }}"
    target_role: "{{ item.username }}"
    state: present
  with_items: "{{ postgres_users }}"
  become_user: "{{ postgres_user }}"
  become: yes
  when:
    item.granted_roles|default([]) is not empty

# Since we may have changed the Postgres configuration, we repeat the
# cluster discovery process that was done at the beginning (roles/init).

- include_role: name=postgres/facts

# If there's an entry for pgbouncer_auth_user in postgres_users (which
# means the pgbouncer role was applied earlier), we must ensure that a
# pgbouncer_get_auth() function is available in every database.

- include_tasks:
    file: pgbouncer.yml
    apply:
      tags: pgbouncer
  when: >
    postgres_users|json_query("[?username=='%s']" % pgbouncer_auth_user) != []
  tags: pgbouncer

# If there's an entry for a harp_dcs_user in postgres_users, we must
# grant it the required privileges.

- include_tasks:
    file: harp.yml
    apply:
      tags: harp
  when:
    - harp_dcs_user is defined
    - postgres_users|json_query("[?username=='%s']" % harp_dcs_user) != []
  tags: harp

- name: Include postgres-config-final hook
  include_tasks: "{{ hook }}"
  when:
    lookup('first_found', dict(files=hook, skip=True))
  vars:
    hook: "{{ cluster_dir }}/hooks/postgres-config-final.yml"
  tags: always
