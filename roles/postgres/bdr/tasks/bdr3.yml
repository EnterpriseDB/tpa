---

# Copyright © EnterpriseDB Corporation

# We need to create the local BDR node if bdr.node is empty.
#
# If it's not empty, it may contain either one row for the local node
# (if it hasn't joined the BDR group yet) or rows for each node in the
# group. In either case, we know that the local node must exist already.

- name: Include bdr-pre-node-creation hook
  include_tasks: "{{ hook }}"
  when:
    bdr_database_facts.bdr.node is empty
    and lookup('first_found', dict(files=hook, skip=True))
  vars:
    hook: "{{ cluster_dir }}/hooks/bdr-pre-node-creation.yml"
  tags: always

- name: Create BDR node if necessary
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    queries:
      - text: SELECT bdr.create_node(node_name := %s, local_dsn := %s) AS node_id
        args:
          - "{{ bdr_node_name }}"
          - "{{ bdr_node_dsn }}"
  become_user: "{{ postgres_user }}"
  become: yes
  register: new_bdr_node
  changed_when: True
  when:
    bdr_database_facts.bdr.node is empty

- name: Set bdr_node_id for each node
  set_fact:
    bdr_node_id: "{{ known_id or new_bdr_node.node_id }}"
  vars:
    known_id:
      "{{ bdr_database_facts.bdr.local_node.node_id|default('') }}"

- name: Map node numbers to bdr_node_ids
  set_fact:
    bdr_node_ids: "{{
      bdr_node_ids|default({})|combine({
        hostvars[item].node: hostvars[item].bdr_node_id
      })
    }}"
  with_items: "{{ groups[bdr_node_group] }}"
  when:
    hostvars[item].bdr_node_id is defined

# Now we must ensure that the required BDR node groups exist.
#
# The first_bdr_primary will create every group in bdr_node_groups; or
# if that is not set, it will create the group named by bdr_node_group
# (along with bdr_node_group_options, if any are specified).

- name: Set default bdr_node_groups if needed
  set_fact:
    bdr_node_groups: ["{{ _default_group }}"]
  when:
    bdr_node_groups is not defined
  vars:
    _name: "{{ {'name': bdr_node_group} }}"
    _options: "{{ bdr_node_group_options|default({}) }}"
    _default_group: "{{ _name|combine(_options) }}"

- name: Map BDR group names to options
  set_fact:
    _bdr_group_options: "{{
      _bdr_group_options|default({})|combine({group: options})
    }}"
  with_items: "{{ bdr_node_groups }}"
  vars:
    group: "{{ item.name }}"
    options: "{{ item|remove_keys(['name']) }}"

# Now we check if bdr.node_group has entries for all the groups named in
# bdr_node_groups. If not, the first_bdr_primary must create each group
# and the other instances must join their respective group.

- name: Enumerate BDR group names
  set_fact:
    have_bdr_group_names: "{{ bdr_database_facts.bdr.node_group|map(attribute='node_group_name')|list }}"
    want_bdr_group_names: "{{ bdr_node_groups|map(attribute='name')|list }}"

# We always call create_node_group() with "node_group_name := %s" and
# the name of the node group; if bdr_node_group_options specifies any
# other parameters, we pass them through as well.

- name: Create BDR node groups if necessary
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    queries:
      - text: "SELECT bdr.create_node_group({{ _option_string }}) AS node_group_id"
        args: "{{ _values }}"
  become_user: "{{ postgres_user }}"
  become: yes
  register: new_bdr_group
  with_items: "{{ want_bdr_group_names }}"
  loop_control:
    loop_var: _group
  vars:
    _group_options: "{{ _bdr_group_options[_group] }}"
    _join_options: "{{
      (_group == bdr_node_group or
       (bdr_child_group is defined and
        _group == bdr_child_group) or
       'parent_group_name' not in _group_options)
      |ternary({}, {'join_node_group': 'f'})
    }}"
    _options: "{{ _group_options|combine(_join_options) }}"
    _keys: "{{ query('flattened', ['node_group_name', _options.keys()|list]) }}"
    _values: "{{ query('flattened', [_group, _options.values()|list]) }}"
    _option_string: >
      {{ _keys|map('apply_format', '{0} := %s')|list|join(', ') }}
  when:
    inventory_hostname == first_bdr_primary
    and _group not in have_bdr_group_names
  changed_when: True

- name: Identify logical standby nodes
  set_fact:
    bdr_node_pause_in_standby: "{{
      bdr_node_pause_in_standby|default('readonly' in role)
    }}"

- name: Include bdr-post-group-creation hook
  include_tasks: "{{ hook }}"
  when:
    have_bdr_group_names|length < want_bdr_group_names|length and
    lookup('first_found', dict(files=hook, skip=True))
  vars:
    hook: "{{ cluster_dir }}/hooks/bdr-post-group-creation.yml"
  tags: always

# Set up replication sets according to the publications/subscriptions
# settings before group join.

- name: Configure replication sets
  include_tasks:
    file: bdr3/replication-sets.yml
    apply:
      tags: replication-sets
  vars:
    q: >-
      [?type=='bdr' && database=='%s'].replication_sets|[]
    _publication_sets: >-
      {{ publications|json_query(q % bdr_database) }}
    _subscription_sets: >-
      {{ subscriptions|json_query(q % bdr_database) }}
    publication_sets: >-
      {{ _publication_sets|map('pyformat_attr', 'name', bdr_node_ids=bdr_node_ids)|list }}
    subscription_sets: >-
      {{ _subscription_sets|map('pyformat', bdr_node_ids=bdr_node_ids)|list }}
  tags: replication-sets

# The first_bdr_primary has now created the group, and the remaining members
# of the same bdr_node_group must join the group.
#
# BDR does not support concurrent group joins, so we can't run this task
# in parallel on all the members of the group. Failing that, it would be
# nice to set «serial: 1» on this task, but serial is not supported as a
# task attribute. We use a loop to get the equivalent serial behaviour,
# executing the task on first_bdr_primary, but connecting to each instance
# in turn to issue the bdr.join_node_group() query.

- include_tasks: bdr3/join.yml
  when:
    inventory_hostname == first_bdr_primary
