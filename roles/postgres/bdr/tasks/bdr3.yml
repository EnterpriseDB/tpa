---

# Copyright © 2ndQuadrant Limited <info@2ndquadrant.com>

# We need to create the local BDR node if bdr.node is empty.
#
# If it's not empty, it may contain either one row for the local node
# (if it hasn't joined the BDR group yet) or rows for each node in the
# group. In either case, we know that the local node must exist already.

- name: Check if the BDR node has been created already
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    queries:
      - text: SELECT node_id FROM bdr.node WHERE dbname = %s
        args:
          - "{{ bdr_database }}"
  register: bdr_node_tuples
  become_user: "{{ postgres_user }}"
  become: yes

- name: Include bdr-pre-node-creation hook
  include_tasks: "{{ hook }}"
  when:
    bdr_node_tuples.rowcount == 0 and
    lookup('first_found', dict(files=hook, skip=True))
  vars:
    hook: "{{ cluster_dir }}/hooks/bdr-pre-node-creation.yml"
  tags: always

- name: Create BDR node if necessary
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    queries:
      - text: SELECT bdr.create_node(node_name := %s, local_dsn := %s)
        args:
          - "{{ bdr_node_name }}"
          - "{{ bdr_node_dsn }}"
  when:
    bdr_node_tuples.rowcount == 0
  become_user: "{{ postgres_user }}"
  become: yes

# We use local_node_info() here instead of querying bdr.node, because we
# want each instance to retrieve only its own local node_id.

- name: Retrieve bdr_node_id for each instance
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    query: SELECT node_id FROM bdr.local_node_info()
  register: bdr_node_tuple
  become_user: "{{ postgres_user }}"
  become: yes

- name: Set bdr_node_id
  set_fact:
    bdr_node_id: "{{ bdr_node_tuple.node_id }}"

# Each instance checks if bdr.node_group contains an entry for its own
# bdr_node_group. If not, the first_bdr_primary must create the group
# and the other instances must join it.

- name: Check if the BDR groups have been created already
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    queries:
      - text: SELECT node_group_id FROM bdr.node_group WHERE node_group_name = %s
        args:
          - "{{ bdr_node_group }}"
  register: bdr_node_group_tuples
  become_user: "{{ postgres_user }}"
  become: yes

- name: Identify logical standby nodes
  set_fact:
    bdr_node_pause_in_standby: "{{
      bdr_node_pause_in_standby|default('readonly' in role)
    }}"

# We always call create_node_group() with "node_group_name := %s" and
# the name of the node group; if bdr_node_group_options specifies any
# other parameters, we pass them through as well.

- name: Create BDR node groups if necessary
  postgresql_query:
    conninfo: "{{ bdr_node_dsn }}"
    queries:
      - text: "SELECT bdr.create_node_group({{ _option_string }})"
        args: "{{ _values }}"
  become_user: "{{ postgres_user }}"
  become: yes
  when:
    inventory_hostname == first_bdr_primary and
    bdr_node_group_tuples.rowcount == 0
  vars:
    _options: "{{ bdr_node_group_options|default({}) }}"
    _keys: "{{ query('flattened', ['node_group_name', _options.keys()]) }}"
    _values: "{{ query('flattened', [bdr_node_group, _options.values()]) }}"
    _option_string: >
      {{ _keys|map('apply_format', '{0} := %s')|list|join(', ') }}

- name: Include bdr-post-group-creation hook
  include_tasks: "{{ hook }}"
  when:
    bdr_node_group_tuples.rowcount == 0 and
    lookup('first_found', dict(files=hook, skip=True))
  vars:
    hook: "{{ cluster_dir }}/hooks/bdr-post-group-creation.yml"
  tags: always

- name: Clean up bdr database before group join
  include_tasks: clean.yml
  when:
    inventory_hostname != first_bdr_primary and
    bdr_node_group_tuples.rowcount == 0
  tags: always

- name: Configure replication sets
  include_tasks:
    file: bdr3/replication-sets.yml
    apply:
      tags: [bdr, replication-sets]
  vars:
    q: >-
      [?type=='bdr' && database=='%s'].replication_sets|[]
    publication_sets: >-
      {{ publications|default([])|json_query(q % bdr_database) }}
    subscription_sets: >-
      {{ subscriptions|default([])|json_query(q % bdr_database) }}
  tags: [bdr, replication-sets]

# The first_bdr_primary has now created the group, and the remaining members
# of the same bdr_node_group must join the group.
#
# BDR does not support concurrent group joins, so we can't run this task
# in parallel on all the members of the group. Failing that, it would be
# nice to set «serial: 1» on this task, but serial is not supported as a
# task attribute. We use a loop to get the equivalent serial behaviour,
# executing the task on first_bdr_primary, but connecting to each instance
# in turn to issue the bdr.join_node_group() query.

- include_tasks: bdr3/join.yml
  when:
    inventory_hostname == first_bdr_primary
  tags: always
