---

# Â© Copyright EnterpriseDB UK Limited 2015-2022 - All rights reserved.

# The first time we reach here on a new instance, we know only what
# distribution it is running, but we take nothing else for granted,
# including the presence of a usable Python interpreter.
#
# We invoke sys/bootstrap to check whether the basic requirements are
# satisfied, and install them otherwise; but instances without outside
# network access can't install anything that's missing, so we invoke
# sys/local-repo first (in such an environment, the local-repo must
# provide all packages required during deployment).

- include_role:
    name: sys/local-repo
    apply:
      tags: local-repo
  tags: local-repo

# Now that all instances have a source of packages (either the network
# or the local-repo), we can check what's missing and install it. After
# this stage, we can run any Ansible modules we need.

- include_role:
    name: sys/bootstrap
    apply:
      tags: bootstrap
  tags: bootstrap

# Now we set up package repositories, including {apt,yum}_repositories
# entries mentioned in {apt,yum}_repository_list (e.g., PGDG, EPEL), and
# any EDB/2ndQuadrant repositories we might need (tpa_2q_repositories).

- include_role:
    name: sys/repositories
    apply:
      tags: [pkg, repo]
  tags: [pkg, repo]

# Once the repositories are available, we can install any other
# (non-Postgres-related) packages we need.

- include_role:
    name: sys/pkg
    apply:
      tags: pkg
  tags: pkg

- name: Set the hostname
  hostname:
    name: "{{ inventory_hostname }}"
    use: systemd
  when:
    platform not in ['docker']
  tags: hostname

- name: Ensure authorized_keys allows admin access
  authorized_key:
    user: "{{ ansible_user|default('root') }}"
    key: "{{ lookup('file', cluster_dir|abspath_to(ssh_key_file + '.pub')) }}"
  when: ssh_key_file is defined

- include_tasks:
    file: tpa.yml
    apply:
      tags: tpa
  tags: tpa

# Creates and mounts any additional filesystems required, e.g., any
# postgres_data/barman_data volumes specified for the instance.

- include_role:
    name: sys/fs
    apply:
      tags: fs
  with_items: "{{ volumes }}"
  loop_control:
    loop_var: volume
    label: >-
      {{ volume.device }}
  tags: fs

# Now that the any additional volumes have been mounted, we can copy in
# any additional artifacts specified in config.yml
- include_tasks:
    file: artifact.yml
    apply:
      tags: artifacts
  with_items: "{{ artifacts|default([]) }}"
  loop_control:
    loop_var: artifact
  tags: artifacts

- include_role:
    name: sys/sysctl
    apply:
      tags: sysctl
  when:
    platform not in ['docker', 'lxd']
  tags: sysctl

- include_role:
    name: sys/sysstat
    apply:
      tags: sysstat
  tags: sysstat

- include_role:
    name: sys/openvpn
    apply:
      tags: openvpn
  when: >
    platform not in ['docker', 'vagrant'] and
    'role_openvpn-server' in groups
  tags: always

- include_role:
    name: sys/hosts
    apply:
      tags: hosts
  tags: hosts

- include_role:
    name: sys/hostkeys
    apply:
      tags: hostkeys
  tags: hostkeys

- include_role:
    name: sys/cloudinit
    apply:
      tags: cloudinit
  when: >
    platform not in ['docker', 'lxd', 'vagrant']
  tags: cloudinit

- include_role:
    name: sys/ssl
    apply:
      tags: ssl
  tags: ssl

- include_role:
    name: sys/rsyslog
    apply:
      tags: rsyslog
  tags: rsyslog

- include_role:
    name: sys/logrotate
    apply:
      tags: rsyslog
  tags: rsyslog

# https://github.com/CentOS/CentOS-Dockerfiles/issues/173
#
# Retained for compatibility with centos/systemd docker containers;
# harmless everywhere else.

- name: Ensure /run/nologin does not exist
  file:
    path: /run/nologin
    state: absent
  when: platform in ['docker']
