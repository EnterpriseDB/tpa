---

# Â© Copyright EnterpriseDB UK Limited 2015-2024 - All rights reserved.

- name: Ensure efm configuration directory exists
  file:
    path: "{{ efm_conf_dir }}"
    owner: efm
    group: efm
    mode: "0755"
    state: directory

- name: Include role postgres/createuser
  include_role: name=postgres/createuser
  vars:
    username: efm
    role_attrs:
    - superuser
    password_encryption: md5

- name: Allow efm user to run db function as {{ postgres_user }}
  community.general.sudoers:
    name: "efm_run_as_{{ postgres_user }}"
    state: present
    user: efm
    runas: "{{ postgres_user }}"
    commands: "{{ efm_bin_dir }}/efm_db_functions"
  when: >
    failover_manager == "efm"

# EFM requires MD5 authentication, but instead of storing an MD5 secret,
# it uses a homebrew "encryption" scheme that feeds the cluster name to
# PBKDF2 to derive a key to encrypt the password. Also, there is no way
# to run `efm encrypt` and provide the password non-interactively on
# stdin; you have to pass it in through the environment.

- name: Encrypt efm password
  shell: >
    "{{ efm_bin_dir }}"/efm encrypt "{{ cluster_name }}" --from-env
  environment: "{{ target_environment|combine(_task_environment) }}"
  vars:
    _task_environment:
      EFMPASS: "{{ efm_password }}"
  register: efm_encrypted_pass_output
  changed_when: false
  no_log: true

- name: Configure efm for syslog
  block:

    - name: Load syslog_efm_conf_settings
      include_vars:
        file: log-server-defined.yml

    - name: Configure efm for syslog
      set_fact:
        efm_conf_settings: "{{ syslog_efm_conf_settings|combine(efm_conf_settings) }}"

  when:
    - log_server is defined
    - log_server != inventory_hostname

# Ensure EFM properties file exists before executing
# any EFM commands in the block below
- name: Check for efm properties file location
  stat:
    path: "{{ efm_conf_dir }}/{{ cluster_name }}.properties"
  register: efm_cluster_properties

# After a switchover, the current 'Primary' node must be determined from EFM
- name: Update upstream_primary to reflect switchover
  block:
    - name: Get current EFM cluster status
      command: >
        {{ efm_bin_dir }}/efm cluster-status-json {{ cluster_name }}
      when: >
        'primary' in role or 'replica' in role
      register: cluster_status
      retries: 5
      delay: 2
      until: cluster_status is success
      become_user: "{{ postgres_user }}"
      become: yes

    # Create a dictionary of nodes in EFM cluster from output of `cluster-status-json`
    - name: Get EFM nodes
      set_fact:
        efm_nodes: "{{ status.nodes | dict2items(key_name='ip', value_name='info') }}"
      vars:
        status: "{{ cluster_status.stdout|from_json }}"
      when: >
        cluster_status is defined and cluster_status is success

    # Set the IP address of the node marked 'primary'
    - name: Loop over efm_nodes
      set_fact:
        primary_ip: "{{ item.ip }}"
      loop: "{{ efm_nodes }}"
      when: >
        item.info.type | lower == 'primary'
    
    # Loop over all the hosts on which the play runs.
    # When the ip address of the host matches the ip address of the `primary`
    # node (determined above), set the 'upstream_primary' to the name of that host.
    - name: Assign new upstream_primary
      set_fact:
        upstream_primary: "{{ item }}"
      loop: "{{ play_hosts }}"
      when: >
        hostvars[item].ip_address == primary_ip
          
  when: efm_cluster_properties.stat.islnk is defined
  run_once: true
  delegate_to: "{{ upstream_primary }}"


- name: Install efm.properties for {{ cluster_name }}
  template:
    src: efm.properties.j2
    dest: "{{ efm_conf_dir }}/{{ cluster_name }}.properties"
    owner: efm
    group: efm
    mode: "0640"
  vars:
    efm_encrypted_pass: "{{ efm_encrypted_pass_output.stdout }}"
  notify:
    - Note efm restart required

- name: Install efm.nodes
  template:
    src: efm.nodes.j2
    dest: "{{ efm_conf_dir }}/{{ cluster_name }}.nodes"
    owner: efm
    group: efm
    mode: "0640"
  vars:
    node_ips: "{{
        groups[cluster_tag] | map('extract', hostvars, ['ip_address']) | product([efm_bind_port]) | map('join', ':') | join('\n')
      }}"
  notify:
    - Note efm restart required

# EFM requires us to either configure email alerts or provide a custom
# notification script. For now, we install a no-op notification script.

- name: Install efm notification script
  template:
    src: efm.notification.sh.j2
    dest: "{{ efm_conf_dir }}/{{ cluster_name }}-efm.notification.sh"
    owner: efm
    group: efm
    mode: "0750"
