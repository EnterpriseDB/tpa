---

- name: Fail if the data directory exists
  fail:
    msg: "Can't run 'repmgr standby clone' over existing PGDATA"
  when: pgdata_initialised

# Now we have to decide where to clone from.
#
# The obvious answer is our 'upstream' instance, which may be a primary
# or another replica. The problem is that if it's a replica, it may not
# have been initialised yet. We check if we can connect to the upstream
# and if so, clone from it; if not, we clone from the primary and do a
# little magic to make the replication work as desired afterwards.

- include: clone-upstream.yml
  when: >
    upstream|default(upstream_primary) != upstream_primary
    
- name: Run repmgr standby clone
  command: >
    {{ postgres_bin_dir }}/repmgr standby clone -F --verbose \
      -f "{{ repmgr_conf_dir }}/repmgr.conf" -D {{ postgres_data_dir }} \
      -d repmgr -U repmgr -w 0 --fast-checkpoint --no-conninfo-password \
      --copy-external-config-files \
      -h {{ upstream_to_clone|default(upstream_primary) }}
  become_user: "{{ postgres_user }}"
  become: true

# PGDATA didn't exist until we just created it, so postgres/config would
# have skipped this instance earlier. We install the configuration files
# here; on subsequent deployments, postgres/config will manage them with
# the other instances.
#
# XXX We would like to use include_role/tasks_from here, but can't due
# to various bugs, so we duplicate the definition of _include_dir from
# postgres/config/vars.

- include: "{{ tpa_dir }}/roles/postgres/config/tasks/main.yml"
  vars:
    _include_dir: "{{ postgres_data_dir }}/conf.d"
    _postgres_extensions: "{{
      postgres_extensions|default(default_postgres_extensions)
    }}"

- set_fact: pgdata_initialised=True
