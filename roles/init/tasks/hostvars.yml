---

# Â© Copyright EnterpriseDB UK Limited 2015-2023 - All rights reserved.

- name: Set default environment
  set_fact:
    target_environment: "{{ target_environment|default({}) }}"

- name: Set ip_addresses to []
  set_fact:
    ip_addresses: []

- name: Add private_ip to the address list
  set_fact:
    ip_addresses: "{{ ip_addresses|union(['private_ip']) }}"
  when:
    private_ip is defined

- name: Add public_ip to the address list
  set_fact:
    ip_addresses: "{{ ip_addresses|union(['public_ip']) }}"
  when:
    public_ip is defined

- name: Set primary IP address
  set_fact:
    ip_address: "{{ private_ip|default(public_ip) }}"
  when:
    ip_address is not defined

- name: Set default hostname_aliases
  set_fact:
    hostname_aliases: "{{ hostname_aliases|default({}) }}"

- name: Set tpa_2q_repositories from twoq_repositories (compat)
  set_fact:
    tpa_2q_repositories: "{{ twoq_repositories }}"
  when:
    tpa_2q_repositories is not defined and
    twoq_repositories is defined

# We set the postgresql_flavour: pgextended to maintain backwards compatibility
# with existing clusters that have postgresql_flavour: 2q explicitly set.

- set_fact:
    postgresql_flavour: pgextended
  when:
    postgresql_flavour is defined
    and postgresql_flavour == '2q'

# We add the default Postgres Extended repository for --pgextended clusters only if
# no repositories are specified explicitly.

- set_fact:
    tpa_2q_repositories:
      - products/2ndqpostgres/release
  when:
    postgresql_flavour is defined
    and postgresql_flavour == 'pgextended'
    and tpa_2q_repositories is not defined

# We need to ensure that either cloudsmith token (EDB_SUBSCRIPTION_TOKEN) is defined
# or the legacy 2q repo token (TPA_2Q_SUBSCRIPTION_TOKEN)+ EDB repo file
# (EDB_REPO_CREDENTIALS_FILE) when needed.
# we add the new cloudsmith env test and try to rescue the run by checking for
# legacy token when the test fails.
- block:

  # EDB repositories now will be available via cloudsmith,
  # we need to ensure that the EDB cloudsmith token is defined
  # as an environment variable.
  - assert:
      msg: >
        Export EDB_SUBSCRIPTION_TOKEN to use new tpa_edb_repositories
      that:
        lookup('env', 'EDB_SUBSCRIPTION_TOKEN') != ''
    tags: public_repos

  - set_fact:
      edb_repos_token: "{{ lookup('env', 'EDB_SUBSCRIPTION_TOKEN') }}"
      edb_cloudsmith_repo: true
      tpa_2q_repositories: []

  rescue:

  # PGD5+ will only live in cloudsmith repositories, we need to have the token
  # exported into EDB_SUBSCRIPTION_TOKEN otherwise we can safely stop the run.
  - assert:
      msg: "PGD-Always-ON architecture requires you to export EDB_SUBSCRIPTION_TOKEN"
      that: bdr_version is not version('5','>=')
    tags: public_repos

  # To use 2ndQuadrant repositories (e.g., for 2ndQPostgres), get a
  # subscription token from the Customer Portal and export
  # TPA_2Q_SUBSCRIPTION_TOKEN in the environment.
  - assert:
      msg: "Export TPA_2Q_SUBSCRIPTION_TOKEN to use tpa_2q_repositories"
      that:
        lookup('env', 'TPA_2Q_SUBSCRIPTION_TOKEN') != '' or
        tpa_2q_repositories|default([]) is empty
    tags: public_repos

  - assert:
      that: env_token not in expired_tokens
      fail_msg: >-
        Your TPA_2Q_SUBSCRIPTION_TOKEN has expired; please fetch an updated token
        from https://techsupport.enterprisedb.com/customer_portal/company/
    vars:
      env_token: "{{ lookup('env', 'TPA_2Q_SUBSCRIPTION_TOKEN') }}"
      expired_tokens:
      - QGcOzwnsVlaKF5jQfYlIwq57kUbKVtAM
    run_once: yes
    tags: public_repos

  # To use EDB repositories (e.g., for EPAS), get a username/password from
  # https://www.enterprisedb.com/user/register?destination=/repository-access-request
  # and export EDB_REPO_CREDENTIALS_FILE=/path/to/file in the environment,
  # where the file contains a single line with "username:password".

  - block:
    - stat:
        path: "{{ _file }}"
      register: _credsfile
      delegate_to: localhost
    - assert:
        msg: "EDB_REPO_CREDENTIALS_FILE={{ _file }} must exist and have mode 0600"
        that:
        - _credsfile.stat.exists
        - _credsfile.stat.mode == '0600'
    - assert:
        msg: "EDB_REPO_CREDENTIALS_FILE={{ _file }} must contain username:password"
        that:
        - _credentials != ''
        - _credentials.split(':')|length == 2
      vars:
        _credentials: "{{ lookup('file', _file) }}"
    vars:
      _file: "{{ lookup('env', 'EDB_REPO_CREDENTIALS_FILE') }}"
    when:
      _file != ''
    tags: public_repos
  - set_fact:
      edb_cloudsmith_repo: false
- set_fact:
    use_volatile_subscriptions: "{{ use_volatile_subscriptions|default(false)|bool }}"

- set_fact:
    failover_manager: harp
  when:
    failover_manager is not defined
    and enable_harp|default(false)|bool

- assert:
    msg: HARP v1 is no longer recommended or supported, please use HARP
      v2 instead
    that:
      harp_version is not defined or harp_version|int != 1

# If the cluster_dir contained cluster_name.{key,crt} files, we used to
# install them instead of the self-signed certificates on the Postgres
# instances. This behaviour is no longer supported, so we error out if
# the files exist.
#
# TODO: document the recommended alternative certificate mechanism.

- name: Ensure the legacy certificate installation mechanism is not used
  assert:
    msg: >
      Installing the {{ cluster_name }}.key and .crt files is no longer
      supported (but they will not be removed from instances where they
      are already installed); please remove the files to continue.
    that: legacy_certs is empty
  vars:
    legacy_certs:
      "{{ lookup('fileglob',
                 '%s/%s.key' % (cluster_dir, cluster_name),
                 '%s/%s.crt' % (cluster_dir, cluster_name)) }}"

# To use shared PEM server in a given cluster get a username/password for
# the PEM backend database that agents can use to register themselves, put
# them in a file and export EDB_PEM_CREDENTIALS_FILE=/path/to/file in the
# environment. The file contains a single line with "username:password".

- block:
  - stat:
      path: "{{ _file }}"
    register: _credsfile
    delegate_to: localhost
  - assert:
      msg: "EDB_PEM_CREDENTIALS_FILE={{ _file }} must exist and have mode 0600"
      that:
      - _credsfile.stat.exists
      - _credsfile.stat.mode == '0600'
  - assert:
      msg: "EDB_PEM_CREDENTIALS_FILE={{ _file }} must contain username:password"
      that:
      - _credentials != ''
      - _credentials.split(':')|length == 2
    vars:
      _credentials: "{{ lookup('file', _file) }}"
  vars:
    _file: "{{ lookup('env', 'EDB_PEM_CREDENTIALS_FILE') }}"
  when:
    pem_server is defined
    and (hostvars[pem_server].pem_shared|default(false)) is true
