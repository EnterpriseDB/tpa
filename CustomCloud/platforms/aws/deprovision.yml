---

# Decommission an already-provisioned AWS cluster:
#
#     ansible-playbook -i inventory/ec2.py platforms/aws/deprovision.yml \
#         --extra-vars cluster=/path/to/cluster
#
# XXX Doesn't delete elastic IPs or extra provisioned volumes.

- name: Deprovision EC2 cluster
  hosts: localhost
  tasks:
    - include: validate.yml
      tags: always

    - name: Require inventory group {{cluster_tag}} to be defined
      assert:
        msg: "No hosts found in group {{cluster_tag}}"
        that:
          - cluster_tag in groups
          - groups[cluster_tag] | length > 0
      tags: always

    # For each region and each instance in that region, we issue an
    # async ec2 task to deprovision the instance by its id, then wait
    # for all the jobs to complete.

    - name: Terminate EC2 instances in each region
      ec2:
        state: absent
        region: "{{ item.0 }}"
        instance_id: "{{ item.1 }}"
        wait: yes
      with_nested_dependents:
        - regions
        - groups[cluster_tag]|intersect(groups[item.0])|map('extract', hostvars, 'ec2_id')|unique|list
      register: ec2_uninstances
      async: 7200
      poll: 0
      tags: ec2

    - name: Wait for instance deprovisioning to complete
      async_status: jid={{ item.ansible_job_id }}
      register: ec2_jobs
      until: ec2_jobs.finished
      retries: 300
      with_items: "{{ ec2_uninstances.results }}"

    # Next, remove keypairs in each region by the same strategy, except
    # that ec2_key doesn't take a list directly, so we have to use the
    # custom with_nested_dependents plugin instead of with_items. Note
    # that we almost certainly have only a single cluster-wide keypair
    # in each region, but we can cope with any number of keys.

    - name: Remove keypairs in each region
      ec2_key:
        state: absent
        region: "{{ item.0 }}"
        name: "{{ item.1 }}"
        wait: yes
      with_nested_dependents:
        - regions
        - groups[cluster_tag]|intersect(groups[item.0])|map('extract', hostvars, 'ec2_key_name')|unique|list
      tags: ec2_keys

    # Remove the cluster's instance profile role and associated policy.

    - name: Remove inline policy for instance profile
      iam_policy:
        iam_type: role
        iam_name: '{{ cluster_name }}_profile'
        policy_name: '{{ cluster_name }} instance permissions'
        state: absent

    - name: Remove instance profile for cluster
      iam:
        iam_type: role
        name: '{{ cluster_name }}_profile'
        state: absent

    # Before we can delete the VPCs in each region, we must delete the
    # subnets in each VPC. Strangely, we have to use the vpc_id with a
    # CIDR mask to identify a subnet, so we have to iterate over vpc_id
    # from hostvars and subnet masks from instances.
    #
    # This means we will try to remove every known subnet in a region
    # from every known VPC in the region, whether or not we ever created
    # a particular subnet in a particular VPC. But we probably have only
    # one subnet per VPC per region, so we don't waste too much effort.

    - name: Remove VPC subnets in each region
      ec2_vpc_subnet:
        state: absent
        region: "{{ item.0 }}"
        vpc_id: "{{ item.1 }}"
        cidr: "{{ item.2 }}"
      with_nested_dependents:
        - regions
        - groups[cluster_tag]|intersect(groups[item.0])|map('extract', hostvars, 'ec2_vpc_id')|unique|list
        - instances|selectattr('region', 'equalto', item.0)|map(attribute='subnet')|unique|list
      tags: ec2_vpcs

    # Next, we do the same for security groups within the region. Note
    # that 'ec2_security_group_names' is a comma-separated string, which
    # we split into a list in an extra step.

    - name: Remove security groups in each region
      ec2_group:
        state: absent
        region: "{{ item.0 }}"
        name: "{{ item.2 }}"
        description: ''
      with_nested_dependents:
        - regions
        - groups[cluster_tag]|intersect(groups[item.0])|map('extract', hostvars, 'ec2_security_group_names')|unique|list
        - item[1].split(',')
      tags: ec2_vpcs

    # Now we can finally delete each VPC in each region.

    - name: Terminate VPCs in each region
      ec2_vpc:
        state: absent
        region: "{{ item.0 }}"
        vpc_id: "{{ item.1 }}"
        resource_tags: {}
        wait: yes
      with_nested_dependents:
        - regions
        - groups[cluster_tag]|intersect(groups[item.0])|map('extract', hostvars, 'ec2_vpc_id')|unique|list
      tags: ec2_vpcs
