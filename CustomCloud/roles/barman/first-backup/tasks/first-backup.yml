---

# We force an immediate backup of any instance for which we configured
# backups on this run. Barman will not start a backup until the server
# has archived at least one WAL segment, so we try to make sure that
# happens before we try.

# barman/final should have started pg_receivexlog (via barman cron). We
# check by looking for the corresponding entries in pg_stat_replication
# and pg_replication_slots. We know we ran barman cron, so we don't wait
# for the full minute that cron could potentially take to run it.

- name: Check that pg_receivexlog is running
  shell: >
    {{ postgres_bin_dir }}/psql -h {{postgres_host}} -p {{postgres_port}} -qAtc "
    select count(*)
    from pg_stat_replication r join pg_replication_slots s on (r.pid=s.active_pid)
    where application_name='barman_receive_wal' and slot_name='barman' and state='streaming'
    "
  become_user: postgres
  become: yes
  register: receiver
  until: >
    receiver.stdout == '1'
  changed_when: False
  retries: 5
  delay: 3

# Having convinced ourselves that we're streaming, we force a switch to
# a new WAL segment to give the archiver something to do. We could use
# «barman switch-xlog --archive», but that doesn't work on replicas, so
# we run pg_switch_xlog() via psql on the instance or its upstream.

- name: Force switch to a new WAL segment
  command: >
    {{ postgres_bin_dir }}/psql -h {{postgres_host}} -p {{postgres_port}} -qAtc 'select pg_xlogfile_name(pg_switch_xlog())'
  become_user: postgres
  become: yes
  delegate_to: "{{ inventory_hostname|upstream_root(hostvars) }}"
  register: segment
  failed_when: >
    segment|failed and not 'recovery is in progress' in segment.stderr

# Now we have the name of the WAL segment file corresponding to the LSN
# returned by pg_switch_xlog(), and we must wait for it to be archived.
# First, pg_receivexlog will rename streaming/$n.partial to …/$n. Then
# «barman archive-wal» will move it from streaming/ to wals/. We could
# wait for the file to show up in streaming/ and invoke archive-wal to
# archive the segment immediately, but that would be in a race against
# any archive-wal that is invoked by «barman cron». So the file may be
# moved away from streaming/ before we notice it. Instead, we wait for
# the file to appear in wals/. This isn't racy, but it does depend on
# the unpredictable cron invocation of archive-wal.

- name: Wait for old WAL segment to be archived
  wait_for:
    path: "{{ barman_home }}/{{ backup_name }}/wals/{{ segment.stdout[0:16] }}/{{ segment.stdout }}"
    delay: 3
    timeout: 130
  register: archived
  async: 300
  poll: 0
  delegate_to: "{{ backup }}"

# While we're waiting, we can upload the script we'll be using in the
# next step.

- name: Upload barman lockfile script
  copy:
    dest: /tmp/lock
    mode: 0755
    content: |
      #!/usr/bin/env python

      import sys
      from barman.lockfile import LockFile

      if __name__ == '__main__':
          try:
              LockFile(sys.argv[1]).acquire(raise_if_fail=True, wait=True)
          except:
              pass

- name: Wait for async wait_for to complete
  async_status: jid="{{ archived.ansible_job_id }}"
  register: waiting
  until: waiting.finished
  retries: 300

# We know now that «barman archive-wal» has been invoked and moved the
# WAL segment into wals/, but we don't know if it has finished updating
# the xlogdb. We know it must have acquired the WAL archive lock before
# doing so, so we wait to acquire it (and release it) before we invoke
# «barman backup» (which will fail if the segment isn't in xlogdb).

- name: Acquire and release Barman WAL archive lock
  command: /tmp/lock "{{ barman_home }}/.{{ backup_name }}-archive-wal.lock"

- name: Force an immediate backup
  shell: >
    /usr/bin/barman backup "{{ backup_name }}"
  delegate_to: "{{ backup }}"
  become_user: barman
  become: yes
