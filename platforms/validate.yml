---

## Platform-independent validation
#
# Every config.yml needs to set cluster_name and follow certain other
# rules, which we verify here. We also derive the list of platforms
# mentioned by the cluster configuration.

- import_tasks: common/validate.yml

# We derive the list of platforms relevant to this cluster and separate
# instances[] into xxx_instances[] lists for each platform xxx.

- name: Collect list of platforms
  set_fact:
    cluster_platforms: "{{
      cluster_platforms|default([])|union([item.platform])
    }}"
  with_items: "{{ instances }}"
  loop_control:
    label: >-
      {{ item.Name }}

- name: Separate instances into platform-specific lists
  set_fact:
  args:
    "{{ item }}_instances": >
      {{ instances|selectattr('platform', 'equalto', item)|list }}
  with_items: "{{ cluster_platforms }}"

## Platform-specific validation
#
# We use a block here to propagate «tags: always» to the included tasks.

- block:
    - include_tasks: "{{ platform }}/validate.yml"
      with_items:
        "{{ cluster_platforms }}"
      loop_control:
        loop_var: platform
  tags: always

## Final topology validation
#
# Once all the platform-specific validations have been run and given an
# opportunity to fix anything they can, we perform some sanity checks on
# the cluster topology.

- import_tasks: common/validate-topology.yml
