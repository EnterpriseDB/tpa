---

# Provision EC2 instances according to a separate configuration file.
#
# The appropriate AWS IAM credentials must be supplied separately, e.g.
# in ~/.boto or in the environment.

- name: Provision EC2 instances
  hosts: localhost

  # The configuration comes from an external file, but we derive some
  # sensible defaults for internal use. We must use different variable
  # names to avoid template recursion when the values are overriden.

  vars:
    ec2_key_file: "{{ key_file | default('id_' + cluster_name|lower) }}"
    ec2_key_name: "{{ key_name | default('2Q_' + cluster_name|lower) }}"

  tasks:

    # Make sure we're invoked with a complete cluster configuration.

    - block:
        - name: Ensure cluster directory is specified
          assert:
            msg: "Please rerun with «-e cluster=/path/to/dir»"
            that:
              - cluster is defined and cluster != ''

        - name: Derive full path to cluster directory
          set_fact: cluster_dir="{{ cluster|realpath }}"

        - name: Load cluster configuration file
          include_vars: "{{ cluster_dir }}/config.yml"

        - name: Ensure cluster configuration is complete
          assert:
            msg: "Please define cluster configuration in {{cluster}}/config.yml"
            that:
              - cluster_name is defined and cluster_name != ''
              - instances | length > 0
      tags: [always, validate]

    - name: Derive a unique list of regions from instances
      set_fact:
        regions: "{{ instances|map(attribute='region')|unique|list }}"
      tags: always

    - name: Build a list of resources to create in each region
      set_fact:
        vpcs_by_region: "{{ vpcs_by_region|default({})|combine({item: instances|selectattr('region','equalto',item)|map(attribute='subnet')|unique|list}) }}"
      with_items: regions
      tags: always

    # Set up VPCs for each region with a single public subnet and an
    # internet gateway. A VPC is an isolated network zone comprising
    # multiple subnets, gateways, etc.

    - name: Set up VPCs
      ec2_vpc:
        state: present
        region: "{{ item.key }}"
        cidr_block: "{{ item.value }}"
        resource_tags: "{{ cluster_tags }}"
        internet_gateway: yes
        subnets:
          - cidr: "{{ item.value }}"
            resource_tags:
              Name: "{{ cluster_name }}/{{ item.key }}"
        route_tables:
          - subnets:
              - "{{ item.value }}"
            routes:
              - dest: 0.0.0.0/0
                gw: igw
            resource_tags:
              Name: "{{ cluster_name }}/{{ item.key }}"
        wait: yes
      with_dict_of_arrays: vpcs_by_region
      register: vpcs
      tags: ec2_vpcs

    # Set up a security group in each VPC. A security group is a set of
    # firewall rules. We explicitly allow certain incoming traffic; by
    # default, there is an egress rule that allows everything.
    #
    # (There's also a network ACL associated with the VPC that is also a
    # firewall, but we use the default that allows all inbound/outbound
    # traffic. Ansible can't currently operate on ACLs anyway.)

    - name: Set up security groups
      ec2_group:
        state: present
        vpc_id: "{{ item.vpc.id }}"
        region: "{{ item.vpc.region }}"
        name: "{{ cluster_name }}/{{ item.vpc.region }}"
        description: "Security group for {{ cluster_name }} in {{ item.vpc.region }}"
        rules:
          - proto: tcp
            from_port: 22
            to_port: 22
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 443
            to_port: 443
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 5432
            to_port: 5432
            cidr_ip: 0.0.0.0/0
          - proto: udp
            from_port: 1194
            to_port: 1194
            cidr_ip: 0.0.0.0/0
      with_items: vpcs.results
      register: security_groups
      tags: ec2_groups

    # Create an SSH keypair and make sure the public key is stored in
    # each region. This key is used to initially provide SSH access to
    # the EC2 instances we set up next. (We could support multiple keys
    # per region as we do for VPCs, but we don't bother for now.)

    - name: Create a new keypair
      command: ssh-keygen -P "" -f "{{ ec2_key_file }}" -C 2ndQuadrant
      args:
        chdir: "{{ cluster_dir }}"
        creates: "{{ ec2_key_file }}"
      tags: ec2_keys
    - name: Set up keypair in each region
      ec2_key:
        state: present
        region: "{{ item }}"
        name: "{{ ec2_key_name }}"
        key_material: "{{ lookup('file', cluster_dir + '/' + ec2_key_file + '.pub') }}"
        wait: yes
      with_items: regions
      tags: ec2_keys

    # Create EC2 instances using the VPC subnets and security groups and
    # access key we configured above.

    - name: Set up EC2 instances
      ec2:
        exact_count: 1
        count_tag: "{{ cluster_tags }}"
        image: "{{ item.0.image }}"
        region: "{{ item.0.region }}"
        group_id: "{{ item.2.group_id }}"
        instance_type: "{{ item.0.type }}"
        vpc_subnet_id: "{{ item.1.subnets[0].id }}"
        instance_tags: "{{ cluster_tags | combine(item.0.tags) }}"
        key_name: "{{ ec2_key_name }}"
        assign_public_ip: yes
        volumes: "{{ item.0.volumes }}"
        wait: yes
      with_together:
        - instances
        - vpcs.results
        - security_groups.results
      register: ec2_instances
      tags: [ec2, always]

    # Associate an elastic IP with each instance.

    - name: Associate elastic IPs
      ec2_eip:
        state: present
        region: "{{ item.instances[0].region }}"
        instance_id: "{{ item.instances[0].id }}"
        reuse_existing_ip_allowed: true
        in_vpc: true
      with_items: ec2_instances.results
      when: ec2_instances.changed
      register: eips
      tags: [ec2, always]
