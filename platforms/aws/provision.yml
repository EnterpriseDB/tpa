---

# Provision EC2 instances according to a separate configuration file.
#
# The appropriate AWS IAM credentials must be supplied separately, e.g.
# in ~/.boto or in the environment.

- name: Provision EC2 instances
  hosts: localhost

  # The configuration comes from an external file, but we derive some
  # sensible defaults for internal use. We must use different variable
  # names to avoid template recursion when the values are overriden.

  vars:
    ec2_key_file: "{{ key_file | default('id_' + cluster_name|lower) }}"
    ec2_key_name: "{{ key_name | default('2Q_' + cluster_name|lower) }}"

  tasks:

    # Make sure we're invoked with a complete cluster configuration. We
    # expect $cluster_dir/config.yml to define a cluster name and a list
    # of instances.

    - block:
        - name: Ensure cluster directory is specified
          assert:
            msg: "Please rerun with «-e cluster=/path/to/dir»"
            that:
              - cluster is defined and cluster != ''

        - name: Derive full path to cluster directory
          set_fact: cluster_dir="{{ cluster|realpath }}"

        - name: Load cluster configuration file
          include_vars: "{{ cluster_dir }}/config.yml"

        - name: Ensure cluster configuration is complete
          assert:
            msg: "Please define cluster configuration in {{cluster}}/config.yml"
            that:
              - cluster_name is defined and cluster_name != ''
              - instances | length > 0
      tags: [always, validate]

    - name: Derive a unique list of regions from instances
      set_fact:
        regions: "{{ instances|map(attribute='region')|unique|list }}"
      tags: always

    # A VPC (Virtual Private Cloud) is an isolated network container in
    # a single region (although it may span multiple availability zones
    # within the region). It comprises multiple subnets, routing tables,
    # network gateways, etc.
    #
    # For more details, see:
    # https://aws.amazon.com/vpc/
    # https://aws.amazon.com/documentation/vpc/
    #
    # For each unique subnet in instances[], we create a VPC with one
    # subnet (multiple subnets within a VPC are not supported) and an
    # internet gateway with a routing table pointing to it.

    - name: Create VPCs in each region
      ec2_vpc:
        state: present
        region: "{{ item.0 }}"
        cidr_block: "{{ item.1 }}"
        resource_tags: "{{ cluster_tags }}"
        internet_gateway: yes
        subnets:
          - cidr: "{{ item.1 }}"
            resource_tags:
              Name: "{{ cluster_name }}/{{ item.0 }}"
        route_tables:
          - subnets:
              - "{{ item.1 }}"
            routes:
              - dest: 0.0.0.0/0
                gw: igw
            resource_tags:
              Name: "{{ cluster_name }}/{{ item.0 }}"
        wait: yes
      with_nested_dependents:
        - regions
        - instances|selectattr('region','equalto',item.0)|map(attribute='subnet')|unique|list
      register: vpcs
      tags: ec2_vpcs

    # A security group is a set of firewall rules that can be applied to
    # instances in a VPC. (A subnet in a VPC can also have a network ACL
    # associated with it, but we use the default that allows all inbound
    # and outbound traffic. Ansible can't operate on ACLs anyway.)
    #
    # http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html
    # http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html
    #
    # We create a security group for every VPC we created above.

    - name: Create security groups for each VPC
      ec2_group:
        state: present
        vpc_id: "{{ item.vpc.id }}"
        region: "{{ item.vpc.region }}"
        name: "{{ cluster_name }}/{{ item.vpc.region }}"
        description: "Security group for {{ cluster_name }} in {{ item.vpc.region }}"
        rules:
          - proto: tcp
            from_port: 22
            to_port: 22
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 443
            to_port: 443
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 5432
            to_port: 5432
            cidr_ip: 0.0.0.0/0
          - proto: udp
            from_port: 1194
            to_port: 1194
            cidr_ip: 0.0.0.0/0
      with_items: vpcs.results
      register: sgs
      tags: ec2_vpcs

    # Create an SSH keypair and make sure the public key is stored in
    # each region. This key is used to initially provide SSH access to
    # the EC2 instances we set up next. (We could support multiple keys
    # per region as we do for VPCs, but we don't bother for now.)

    - name: Create a new keypair
      command: ssh-keygen -P "" -f "{{ ec2_key_file }}" -C 2ndQuadrant
      args:
        chdir: "{{ cluster_dir }}"
        creates: "{{ ec2_key_file }}"
      tags: ec2_keys
    - name: Set up keypair in each region
      ec2_key:
        state: present
        region: "{{ item }}"
        name: "{{ ec2_key_name }}"
        key_material: "{{ lookup('file', cluster_dir + '/' + ec2_key_file + '.pub') }}"
        wait: yes
      with_items: regions
      tags: ec2_keys

    # Create EC2 instances using the VPC subnets and security groups and
    # access key we configured above. We loop over instances[], look up
    # the VPC and group corresponding to the region/subnet defined for
    # that instance, and extract the relevant subnet or group id from
    # the responses registered above.

    - name: Set up EC2 instances
      ec2:
        exact_count: 1
        count_tag: "{{ cluster_tags|combine(item.tags) }}"
        image: "{{ item.image }}"
        region: "{{ item.region }}"
        key_name: "{{ ec2_key_name }}"
        instance_type: "{{ item.type }}"
        instance_tags: "{{ cluster_tags|combine(item.tags) }}"
        vpc_subnet_id: "{{ vpcs.results|
          selectattr('vpc.region', 'equalto', item.region)|
          selectattr('vpc.cidr_block', 'equalto', item.subnet)|
          map(attribute='subnets')|first|
          selectattr('cidr', 'equalto', item.subnet)|
          map(attribute='id')|first }}"
        group_id: "{{ sgs.results|
          selectattr('item.vpc.region', 'equalto', item.region)|
          selectattr('item.vpc.cidr_block', 'equalto', item.subnet)|
          map(attribute='group_id')|first }}"
        volumes: "{{ item.volumes }}"
        assign_public_ip: yes
        wait: yes
      with_items: instances
      register: ec2_instances
      tags: ec2

    # If explicitly requested, we can also associate an elastic IP with
    # one or more of the instances created above. The instance ids come
    # from the results above, and the configuration is in instances[].

    - name: Associate elastic IPs with instances
      ec2_eip:
        state: present
        region: "{{ item.1.tagged_instances[0].region }}"
        device_id: "{{ item.1.tagged_instances[0].id }}"
        reuse_existing_ip_allowed: true
        in_vpc: true
      when: item.0.assign_eip|d() and item.0.assign_eip
      with_together:
        - instances
        - ec2_instances.results
      register: eips
      tags: ec2_eips
