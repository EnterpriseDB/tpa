---

# Decommission an already-provisioned AWS cluster:
#
#     ansible-playbook -i inventory/ec2.py platforms/aws/deprovision.yml \
#         --extra-vars cluster=/path/to/cluster
#
# XXX Doesn't delete elastic IPs or extra provisioned volumes.

- name: Deprovision EC2 cluster
  hosts: localhost
  tasks:
    - block:
        - name: Require cluster directory to be specified
          assert:
            msg: "Please rerun with «-e cluster=./clusters/name»"
            that:
              - cluster is defined and cluster != ''

        - name: Derive full path to cluster directory
          set_fact: cluster_dir="{{ cluster|realpath }}"

        - name: Load cluster configuration file
          include_vars: "{{ cluster_dir }}/config.yml"

        - name: Ensure cluster configuration is complete
          assert:
            msg: "Please define cluster configuration in {{cluster}}/config.yml"
            that:
              - cluster_name is defined and cluster_name != ''
              - instances | length > 0

        - name: Derive EC2 group name for cluster
          set_fact:
            cluster_tag: "{{ 'tag_Name_' + cluster_name }}"

        - name: Require inventory group {{cluster_tag}} to be defined
          assert:
            msg: "No hosts found in group {{cluster_tag}}"
            that:
              - cluster_tag in groups
              - groups[cluster_tag] | length > 0
      tags: always

    # Since ec2_vpc and ec2_key don't take a list of ids to remove, we
    # need to build up a hash indexed by unique region whose values are
    # lists of unique ids. Then we iterate over the keys and each value
    # in the list in turn using a custom lookup plugin.

    - name: Derive a unique list of regions from instances
      set_fact:
        regions: "{{ instances|map(attribute='region')|unique|list }}"
      tags: always

    - name: Build a list of resources to remove in each region
      set_fact:
        ids_by_region: "{{ ids_by_region|default({})|combine({item: groups[cluster_tag]|intersect(groups[item])|map('lookup', hostvars, 'ec2_id')|list}) }}"
        vpcs_by_region: "{{ vpcs_by_region|default({})|combine({item: groups[cluster_tag]|intersect(groups[item])|map('lookup', hostvars, 'ec2_vpc_id')|unique|list}) }}"
        keys_by_region: "{{ keys_by_region|default({})|combine({item: groups[cluster_tag]|intersect(groups[item])|map('lookup', hostvars, 'ec2_key_name')|unique|list}) }}"
      with_items: regions
      tags: always

    # The ec2 module can take a list of instance ids directly, so we can
    # just use with_dict directly.

    - name: Terminate EC2 instances in each region
      ec2:
        state: absent
        region: "{{ item.key }}"
        instance_ids: "{{ item.value }}"
        wait: yes
      with_dict: ids_by_region
      tags: ec2

    # This will fail, because it does not delete any associated subnet,
    # routing table, internet gateway, or security groups first. But we
    # can deal with that later.

    - name: Terminate VPCs in each region
      ec2_vpc:
        state: absent
        vpc_id: "{{ item.value }}"
        region: "{{ item.key }}"
        resource_tags: {}
        wait: yes
      with_dict_of_arrays: vpcs_by_region
      tags: ec2_vpcs

    # We will probably just have the single cluster-wide keypair in each
    # region, but we can cope with any number of keys.

    - name: Remove keypairs in each region
      ec2_key:
        state: absent
        name: "{{ item.value }}"
        region: "{{ item.key }}"
        wait: yes
      with_dict_of_arrays: keys_by_region
      tags: ec2_keys
