#!/usr/bin/env perl
# Copyright Â© EnterpriseDB Corporation
#
# subnets 3
#   Returns 3 randomly-selected /28 subnets under 10.33.x.x
#
# subnet 3 10.22.x.x/27
#   Returns 3 randomly-selected /27 subnets under 10.22.x.x

use strict;
use List::Util 'shuffle';
use File::Find;

my $wanted = shift @ARGV
    or die "ERROR: number of subnets not specified\n";

my $pattern = shift @ARGV || $ENV{SUBNET_PATTERN} || "10.33.x.x";

my $exclusions = $ENV{EXCLUDE_SUBNETS_FROM};

# The pattern may be a.b.c.d or a.b.c.d/nn, and we want to end up with
# [a.b.c.d, nn], where both parts have default values.

my $size = 28;
if ($pattern =~ m#/#) {
    ($pattern, $size) = $pattern =~ m#^(.*)/(.*)$#;
}

# We require the subnet size to be between 24 and 29 (a /29 being the
# smallest subnet that AWS permits), and hand out /28s by default.

if ($size !~ /^2[4-9]$/) {
    die "ERROR: subnet size must be between 24-29: $size\n";
}

# Now we look at each component in our a.b.c.d pattern.
#
# We require the pattern to specify at least the first 16 bits of the
# address (a /16 being the largest VPC network that AWS permits).
#
# The first two components must be numbers. The third or fourth
# component may also be a number, so long as both of them are not
# numbers (because such a pattern would permit no choice at all).

my @components = split /\./, $pattern, 4;

my @octets;
while ($components[0] =~ /^[0-9]{1,3}/) {
    push @octets, shift @components;
}

if (@octets < 2) {
    die "ERROR: subnet pattern must have at least the first two octets filled: $pattern\n";
}
if (@octets == 4) {
    die "ERROR: subnet pattern leaves no room to fill in anything: $pattern\n";
}

# Depending on how many leading numbers we removed, we're left with one
# of the following possibilities: x.num, x.x, and x.

my @pieces = ();

while (@components) {
    # We calculate how many bits of network address we have built up so
    # far based on the number of components remaining, and then generate
    # choices for up to eight of the remaining bits at a time.

    my @choices;

    my $needed = $size - 8*(4 - @components);
    if ($needed > 8) {
        $needed = 8;
    }

    # An 'x' could match (0..254), but if we need fewer than 8 bits, the
    # choices must be restricted to octets with the correct number of
    # trailing zero bits.

    my $component = shift @components;
    if ($component eq "x") {
        @choices = grep { $_ != 255 } (0 .. 2**$needed-1);
        if ($needed < 8) {
            @choices = map $_ << (8-$needed), @choices;
        }
    }

    # A number leaves no choice for this octet, but we check to make
    # sure that it has the expected number of trailing zero bits.

    elsif ($component =~ /^[0-9]+$/ && 0 <= $component && $component <= 254) {
        my $zeroes = 8-$needed;
        if (($component & 2**$zeroes-1) != 0) {
            die "ERROR: need octet with last $zeroes bits unset, got: $component\n";
        }
        @choices = ($component);
    }

    else {
        die "ERROR: subnet pattern contains unexpected component: $component\n";
    }

    # "Multiply" the last round's choices with this round's choices.
    #
    # An a.b.x.x/29 pattern would generate 255*32 possibilities here.

    if (@pieces) {
        my @expanded;
        foreach my $c (@pieces) {
            foreach my $d (@choices) {
                push @expanded, "$c.$d";
            }
        }
        @choices = @expanded;
    }
    @pieces = @choices;
}

# Map every a.b.c.d/x to [int(a.b.c.d), x].
#
# Note that we generated @pieces to have the correct number of zero bits
# at the end already.

my $prefix = join(".", @octets);
my %subnet_map =
    map { ("$_/$size" => [unpack("N", pack("C4", split(/\./, $_))), $size]) }
        map { "$prefix.$_" } @pieces;

# Given [int(a.b.c.d), n], returns the IP number masked by n, i.e., with
# the rightmost 32-n bits zero.

sub mask {
    my ($ip, $bits) = @_;

    return $ip & ~(2**(32-$bits)-1);
}

# If any subnet exclusions are specified, look for "subnet: a.b.c.d/n"
# declarations with the right prefix within config.yml files in the
# provided directories, and exclude them from our list.

if ($exclusions) {
    my $subnet = '^\s*subnet:\s*(' . join('\.', @octets) . '\.[0-9.]+)/([0-9]{2})\s*$';

    # Now build a similar map for any existing subnet declarations, but
    # make sure to store the subnets in canonical form (i.e., masked).

    my %old_subnet_map;
    my @dirs = split /\s*,\s*/, $exclusions;
    find(sub {
            if ($_ == "config.yml") {
                if (open(my $fh, $File::Find::name)) {
                    while (my $line = <$fh>) {
                        if ($line =~ qr/$subnet/) {
                            my $o_ip = unpack("N", pack("C4", split(/\./, $1)));
                            my $o_bits = $2;
                            $old_subnet_map{"$1/$2"} =
                                [mask($o_ip, $o_bits), $o_bits];
                        }
                    }
                }
            }
        }, @dirs);

    # Now we compare each generated a.b.c.d/x to each existing a.b.e.f/y
    # to see if one contains the other. If so, we discard that generated
    # subnet.
    #
    # If x <= y, and a.b.c.d/x == a.b.e.f/x, the subnets overlap.

    foreach my $s (keys %subnet_map) {
        my ($s_ip, $s_bits) = @{$subnet_map{$s}};
        foreach my $o (keys %old_subnet_map) {
            my ($o_ip, $o_bits) = @{$old_subnet_map{$o}};

            if (($s_bits <= $o_bits && $s_ip == mask($o_ip, $s_bits)) ||
                ($o_bits < $s_bits && $o_ip == mask($s_ip, $o_bits)))
            {
                delete $subnet_map{$s};
            }
        }
    }
}

my @subnets = keys %subnet_map;

if (@subnets < $wanted) {
    die "ERROR: only @{[scalar @subnets]}/$wanted free /$size subnets found matching $pattern\n";
}

@subnets = shuffle(@subnets);
@subnets = splice @subnets, 0, $wanted;

print join(" ", @subnets), "\n";
