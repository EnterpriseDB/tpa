#!/usr/bin/env perl
#
# subnets 3
#   Returns 3 randomly-selected /28 subnets under 10.33.x.x
#
# subnet 3 10.22.x.x/27
#   Returns 3 randomly-selected /27 subnets under 10.22.x.x

use strict;
use List::Util 'shuffle';

my $wanted = shift @ARGV
    or die "ERROR: number of subnets not specified\n";

my $pattern = shift @ARGV || $ENV{SUBNET_PATTERN} || "10.33.x.x";

# The pattern may be a.b.c.d or a.b.c.d/nn, and we want to end up with
# [a.b.c.d, nn], where both parts have default values.

my $size = 28;
if ($pattern =~ m#/#) {
    ($pattern, $size) = $pattern =~ m#^(.*)/(.*)$#;
}

# We require the subnet size to be between 24 and 29 (a /29 being the
# smallest subnet that AWS permits), and hand out /28s by default.

if ($size !~ /^2[4-9]$/) {
    die "ERROR: subnet size must be between 24-29: $size\n";
}

# Now we look at each component in our a.b.c.d pattern.
#
# We require the pattern to specify at least the first 16 bits of the
# address (a /16 being the largest VPC network that AWS permits).
#
# The first two components must be numbers. The third or fourth
# component may also be a number, so long as both of them are not
# numbers (because such a pattern would permit no choice at all).

my @components = split /\./, $pattern, 4;

my @octets;
while ($components[0] =~ /^[0-9]{1,3}/) {
    push @octets, shift @components;
}

if (@octets < 2) {
    die "ERROR: subnet pattern must have at least the first two octets filled: $pattern\n";
}
if (@octets == 4) {
    die "ERROR: subnet pattern leaves no room to fill in anything: $pattern\n";
}

# Depending on how many leading numbers we removed, we're left with one
# of the following possibilities: x.num, x.x, and x.

my @subnets = ();

while (@components) {
    # We calculate how many bits of network address we have built up so
    # far based on the number of components remaining, and then generate
    # choices for up to eight of the remaining bits at a time.

    my @choices;

    my $needed = $size - 8*(4 - @components);
    if ($needed > 8) {
        $needed = 8;
    }

    # An 'x' could match (0..254), but if we need fewer than 8 bits, the
    # choices must be restricted to octets with the correct number of
    # trailing zero bits.

    my $component = shift @components;
    if ($component eq "x") {
        @choices = grep { $_ != 255 } (0 .. 2**$needed-1);
        if ($needed < 8) {
            @choices = map $_ << (8-$needed), @choices;
        }
    }

    # A number leaves no choice for this octet, but we check to make
    # sure that it has the expected number of trailing zero bits.

    elsif ($component =~ /^[0-9]+$/ && 0 <= $component && $component <= 254) {
        my $zeroes = 8-$needed;
        if (($component & 2**$zeroes-1) != 0) {
            die "ERROR: need octet with last $zeroes bits unset, got: $component\n";
        }
        @choices = ($component);
    }

    else {
        die "ERROR: subnet pattern contains unexpected component: $component\n";
    }

    # "Multiply" the last round's choices with this round's choices.
    #
    # An a.b.x.x/29 pattern would generate 255*32 possibilities here.

    if (@subnets) {
        my @expanded;
        foreach my $c (@subnets) {
            foreach my $d (@choices) {
                push @expanded, "$c.$d";
            }
        }
        @choices = @expanded;
    }
    @subnets = @choices;
}

if (@subnets < $wanted) {
    die "ERROR: only @{[scalar @subnets]}/$wanted free /$size subnets found matching $pattern\n";
}

# XXX Now's the time to filter out any entries in @subnets that conflict
# with already-assigned subnets, however we can enumerate those.

@subnets = shuffle(@subnets);
@subnets = splice @subnets, 0, $wanted;

my $prefix = join(".", @octets);
print join(" ", map "$prefix.$_/$size", @subnets), "\n";
