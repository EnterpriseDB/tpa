#!/usr/bin/env perl
#
# This daemon is meant to run all the time, listening for a signal to
# rescan the queue table and process every job therein. It's a simple
# way to send mail outside the HTTP request/response cycle; it has no
# pretensions to being a high-performance queue manager.

use 5.12.0;
use DBI;
use strict;
use warnings;
use DateTime;

use File::Basename 'dirname';
use File::Spec::Functions 'splitdir';

use lib join '/', splitdir(dirname(__FILE__)), '../lib';
use lib join '/', splitdir(dirname(__FILE__)), '../local/lib/perl5';

use Mojo::JSON;
use Mojo::Server;

my $TIMEOUT = 10;

#my $script = shift @ARGV
    #or die "Usage: $0 /path/to/app\n";

#my $app = Mojo::Server->new->load_app($script);

#my $signal = $app->config('dequeued_name');
#my $signal = 

my $driver = "SQLite"; 
my $dbfile = "/home/devashish/.pgadmin/2qpgadmin4.db";
my $dsn = "DBI:$driver:dbname=$dbfile";
my $user = "";
my $password = "";

my $dbh = DBI->connect($dsn, $user, $password) or die $DBI::errstr;
my $signal = 'queue';

$| = 1;

print "starting up\n";
print Mojo::Version;


#my $dbh = $app->db;

#$dbh->do(qq{NOTIFY "$signal", 'restart'})
    ##or die "Couldn't send restart: ", $dbh->errstr, "\n";

#$dbh->do(qq{LISTEN "$signal"})
    #or die "Couldn't listen: ", $dbh->errstr, "\n";

#$app->log->info(qq{dequeued[$$]: started, listening for "$signal"});

run_queue();

while (1) {
    my $notify = wait_for_notify();

    process_notification(@$notify);
}

sub wait_for_notify {
    my $notify;

    while (1) {
        eval {
            local $dbh->{RaiseError} = 1;

            do {
                $notify = $dbh->pg_notifies;
                if (!$notify) {
                    my $fd = $dbh->{pg_socket};
                    if ($fd > 0) {
                        vec(my $rfds = "", $fd, 1) = 1;
                        select($rfds, undef, undef, $TIMEOUT);
                    }
                }
            }
            while (!$notify);
        };

        if ($@) {
            chomp(my $err = $@);
            #$app->log->info("dequeued[$$]: lost database connection");
            sleep($TIMEOUT);
        }
        else {
            last;
        }

        eval {
            $dbh->disconnect;
	    $dbh = DBI->connect($dsn, $user, $password) or die $DBI::errstr;
            #$dbh = $app->db;
            local $dbh->{RaiseError} = 1;
            #$dbh->do(qq{LISTEN "$signal"});
        };

        if ($@) {
            chomp(my $err = $@);
            #$app->log->error("dequeued[$$]: reconnect failed; exiting: $err");
            exit;
        }
        else {
            #$app->log->info("dequeued[$$]: reconnected; running queue");
            run_queue();
        }
    }

    return $notify;
}

sub process_notification {
    my ($name, $pid, $payload) = @_;

    #$app->log->debug(
     #   qq{dequeued[$$]: Received NOTIFY "$name", "$payload" from $pid}
    #);

    # If we receive a restart message, we assume it's from a dequeued
    # that's starting up, and politely quit. (Since we send the NOTIFY
    # before we LISTEN, we should never receive our own signal.)

    if ($payload eq "restart") {
        #$app->log->info("dequeued[$$]: Exiting due to restart signal.");
        exit;
    }

    # At the moment, each NOTIFY serves as a "sendmail -q", i.e. we wake
    # up and scan the entire queue. We don't use the payload to restrict
    # our efforts.

    run_queue();
}

sub run_queue {
    my $json = Mojo::JSON->new;
	print "run queue\n";
    my $jobs = $dbh->selectall_arrayref(<<"    SQL", {Slice => {}});
        select queue_id, queued_at, user_id, service_id, service_name 
            from queue where dequeued_at is NULL AND completed_at IS NULL
            order by queued_at asc	
    SQL


    unless (defined $jobs) {
	print "returning";
        #$app->log->error("dequeued[$$]: Couldn't read queue: " . $dbh->errstr);
        return;
    }
	print "processing jobs\n";

    foreach my $job (@$jobs) {
	print "Got job to create service: ";
	
        my ($qid, $ts, $uid, $sid, $sname) =
            @$job{qw/queue_id queued_at user_id service_id service_name/};
	print $sname;
	print "\n";

        #$app->log->debug("dequeued[$$]: Processing $tag job #$qid: '$data'");

        my $handler;
	my $srcdir = "/home/devashish/2q/sources/commit/TPA/CustomCloud";
	my $ansible_exec = "$srcdir/utils/ansible-playbook";
	my $ansible_playbook = "$srcdir/platforms/aws/provision.yml";
	my $basedir = $sid.'_'.$sname;
	my $servicedir = "/opt/tpa/clusters/customer/$uid/$basedir";
	my $now = DateTime->now->datetime;
	$now =~ y/T/ /;
	my $dequeue_update_sql = "UPDATE queue SET dequeued_at = ? WHERE queue_id = ?";
	my $rs=$dbh->do($dequeue_update_sql, undef, $now, $qid);
	$DBI::err && die $DBI::errstr;

	print "Dequeued\n";
	eval {	
		my $status= system("$ansible_exec $ansible_playbook -e cluster=$servicedir -vvvv > $servicedir/provision.out ");\
		printf "Exit status: %d\n", $status >> 8;
		if(($status >> 8) != 0) {
			print "Failed, enqueuing again..\n";
			my $failed_update_sql = "UPDATE queue SET failed_at = ?, dequeued_at = NULL WHERE queue_id = ?";
			my $now = DateTime->now->datetime;
			$now =~ y/T/ /;
			my $rs=$dbh->do($failed_update_sql, undef, $now, $qid);
			$DBI::err && die $DBI::errstr;
		}
		else {
			my $completed_update_sql = "UPDATE queue SET completed_at = ? WHERE queue_id = ?";
			my $now = DateTime->now->datetime;
			$now =~ y/T/ /;
			my $rs=$dbh->do($completed_update_sql, undef, $now, $qid);
			$DBI::err && die $DBI::errstr;
			print "Completed\n";
		}
	};

        #eval {
         #   my $class = $app->load("Dequeue::${tag}");
          #  unless ($class) {
           #     die "Couldn't load ::Dequeue::${tag} handler\n";
           # }
            #$handler = $class->new(app => $app);
           # my $hash = $json->decode($data);
          #  $handler->process($hash, $job);
        #};

        if ($@) {
            chomp(my $msg = $@);

            #$app->log->error("dequeued[$$]: $tag job #$qid failed: $msg");
        };

        # XXX We'll need to leave failed jobs on the queue to be retried
        # soon enough, but let's keep it simple for now.

        #$dbh->do("delete from queue where queue_id=?", {}, $qid)
            #or $app->log->error(
             #   "dequeued[$$]: Job #$qid not removed: " . $dbh->errstr
            #);
    }
}
