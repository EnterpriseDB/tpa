#!/usr/bin/env bash
# Copyright © 2ndQuadrant Limited <info@2ndquadrant.com>
#
# The dispatcher for all TPAexec functionality, including initial setup,
# and the configuration, provision, deployment, and testing of clusters.

IFS=$' \t\n'
set -eu
: "${PAGER:=less}"

error() {
    echo "ERROR: $*" >&2
    exit 1
}

# If $TPA_DIR is not already set, we guess TPA_DIR based on $0 (so that
# a git checkout takes precedence over a package installation), or use
# /opt/2ndQuadrant/TPA if it exists.

TOP=/opt/2ndQuadrant/TPA
if [[ -z "${TPA_DIR:-}" ]]; then
    if [[ -h "${self:=$0}" ]]; then
        self=$(readlink "$0")
    fi
    SRC=$(dirname "$self")/..
    type realpath &>/dev/null && SRC=$(realpath "$SRC")
    if [[ -d $SRC/roles ]]; then
        TOP=$SRC
    fi
fi

export TPA_DIR=${TPA_DIR:-$TOP}
if [[ ! -d $TPA_DIR/roles ]]; then
    error "Can't find $TPA_DIR/roles; please set TPA_DIR correctly"
fi

ansible=$TPA_DIR/ansible/ansible
TPA_VENV=$TPA_DIR/tpa-venv

## Command functions
#
# These functions handle the various tpaexec commands.

version() {
    if [[ -f $TPA_DIR/VERSION ]]; then
        VERSION=$(cat "$TPA_DIR/VERSION")
    else
        VERSION=$(cd "$TPA_DIR" && git describe)
    fi
    echo "# TPAexec $VERSION"
}

_python_version() {
    python3 -c 'import sys; print("%d.%d.%d" % (sys.version_info[0:3]))'
}

_detect_venv() {
    python3 -c "import sys; print('venv' if hasattr(sys, 'real_prefix') or sys.base_prefix != sys.prefix else 'no venv')"
}

_ansible_version() {
    python3 -c 'import ansible.release; print(ansible.release.__version__)'
}

_activate_venv() {
    set +u
    if ! source "$1/bin/activate"; then
        error "couldn't source $1/bin/activate (is $1 a venv?)"
    fi
    set -u
}

_create_and_activate_venv() {
    # If we're inside an activated venv already, we don't need to
    # do anything here.

    if [[ "$(_detect_venv)" == "venv" ]]; then
        return
    fi

    # If no venv exists, we have to create it before we try to
    # activate it below.

    if [[ ! -d $vpath ]]; then
        echo "Creating venv $vpath"
        if ! mkdir -p "$vpath"; then
            error "couldn't create $vpath (try ``--venv /other/path`` or use sudo)"
        fi
        python3 -m venv "$vpath"
    fi

    _activate_venv "$vpath"
}

_install_pip_packages() {
    pip_args=(--upgrade)

    if [ -n "${pip_cache_dir:-}" ]; then
        pip_args+=(--cache-dir)
        pip_args+=("${pip_cache_dir}")
    else
        pip_args+=(--no-cache-dir)
    fi

    # If pip packages are bundled (i.e., the tpaexec-deps package has
    # been installed), we configure pip to use them instead of trying
    # to download them from the network.

    PIP_DIR=$TPA_DIR/pip-packages
    if [[ -d $PIP_DIR ]]; then
        pip_args+=(--no-index)
        pip_args+=("--find-links=file:$PIP_DIR")
    fi

    pip3 install "${pip_args[@]}" -r "$TPA_DIR/python-requirements.txt"

    # If we have a local copy of the ansible repository, we want to use
    # it in-situ rather than installing it into the venv (so that any
    # changes take effect immediately). We do still need to install
    # Ansible's own dependencies into the venv.
    #
    # Otherwise, we need to install it into the venv either from the
    # bundled copy of the repository, or directly from github. In this
    # case, pip will install the dependencies automatically.

    if [[ -n "${ANSIBLE_HOME:-}" && -d $ANSIBLE_HOME && -x $ANSIBLE_HOME/bin/ansible ]]; then
        pip3 install "${pip_args[@]}" -r "$ANSIBLE_HOME/requirements.txt"
    else
        if [[ -d $PIP_DIR/ansible ]]; then
            ANSIBLE_REPO=file:$PIP_DIR/ansible
        else
            ANSIBLE_REPO=$(mktemp -d /tmp/ansible-XXXXXXXXXX)
            git clone --depth 1 https://github.com/2ndQuadrant/ansible "$ANSIBLE_REPO"
        fi
        pip3 install "${pip_args[@]}" "$ANSIBLE_REPO"
    fi
}

setup() {
    while [[ $# -gt 0 ]]; do
        opt=$1
        shift

        case "$opt" in
            --venv)
                vpath=${1:?venv location not specified}
                shift
                ;;
            --pip-cache-dir)
                pip_cache_dir=${1:?pip cache directory not specified}
                shift
                ;;
            *)
                error "unrecognised option: $opt"
                ;;
        esac
    done

    _create_and_activate_venv "${vpath:=$TPA_VENV}"
    _install_pip_packages
}

configure() {
    # Find the relevant architecture configuration script and let it do
    # whatever it wants to generate the cluster configuration into the
    # target directory. All arguments belong to that script; we just
    # peek at the command line to find out which architecture to use.

    args=("$@")
    for arg in "${!args[@]}"; do
        if [[ $arg -gt 0 ]]; then
            last=${args[$((arg-1))]}
            if [[ $last == -a || $last == --architecture ]]; then
                arch=${args[$arg]}
                archdir=$TPA_DIR/architectures/$arch
            fi
        fi
    done

    if [[ ! ${arch:-} ]]; then
        error "no architecture specified with -a/--architecture"
    elif [[ ! -d $archdir || ! -x $archdir/configure ]]; then
        error "unknown architecture: $arch"
    fi

    PYTHONPATH=${PYTHONPATH:+$PYTHONPATH:}${ANSIBLE_HOME:+$ANSIBLE_HOME/lib:}$TPA_DIR/architectures/lib \
    ANSIBLE_FILTER_PLUGINS=${ANSIBLE_FILTER_PLUGINS:+$ANSIBLE_FILTER_PLUGINS:}$TPA_DIR/lib/filter_plugins \
    ANSIBLE_LOOKUP_PLUGINS=${ANSIBLE_LOOKUP_PLUGINS:+$ANSIBLE_LOOKUP_PLUGINS:}$TPA_DIR/lib/lookup_plugins \
    ANSIBLE_TEST_PLUGINS=${ANSIBLE_TEST_PLUGINS:+$ANSIBLE_TEST_PLUGINS:}$TPA_DIR/lib/test_plugins \
    "$archdir/configure" "$@"
}

provision() {
    REMAINDER=()
    while [[ $# -gt 0 ]]; do
        opt=$1
        shift

        case "$opt" in
            --owner)
                owner=${1:?Owner not specified}
                shift
                ;;
            --cache*)
                cache=1
                ;;
            --)
                break
                ;;
            *)
                REMAINDER+=("$opt")
                ;;
        esac
    done

    set -- "${REMAINDER[@]:+${REMAINDER[@]}}" "$@"

    "$ansible"-playbook "$TPA_DIR/platforms/provision.yml" \
        ${cache:+-e use_cached_vars=$cache} \
        ${owner:+-e Owner=$owner} \
        -e cluster_dir="$(pwd)" "$@"
}

cmd() {
    $ansible \
        -i inventory --vault-password-file vault/vault_pass.txt \
        -e cluster_dir="$(pwd)" "$@"
}

ping() {
    cmd all -m ping "$@"
}

playbook() {
    args=(-e "tpa_dir=$TPA_DIR")
    args+=(-e "cluster_dir=$(pwd)")

    if [ -d inventory ]; then
        args+=(-i inventory)
    fi

    if [ -f vault/vault_pass.txt ]; then
        args+=(--vault-password-file vault/vault_pass.txt)
    fi

    "$ansible"-playbook "${args[@]}" "$@"
}

deploy() {
    playbook deploy.yml "$@"
}

deprovision() {
    playbook "$TPA_DIR/platforms/deprovision.yml" "$@"
}

rehydrate() {
    instances=${1:?No instances specified}
    shift

    DESTROY=no
    if [ "${1:-'NO_PLEASE_SAVE_MY_CLUSTER'}" = "I_REALLY_WANT_TO_DESTROY_MY_ENTIRE_CLUSTER=yes" ]; then
        DESTROY=yes
        shift
    fi

    # We terminate the old instances after performing some sanity
    # checks, provision replacements for them, and deploy to the
    # newly-provisioned instances.

    playbook "$TPA_DIR/platforms/aws/terminate-for-rehydration.yml" \
        -e i_really_want_to_destroy_my_entire_cluster=$DESTROY \
        --limit "$instances" "$@"

    provision_args=(-e "require_reattachment=yes")
    provision_args+=(-e "reattach_hosts=$instances")
    if [ -f prehydrate-vars.yml ]; then
        provision_args+=(-e @prehydrate-vars.yml)
    fi
    provision "${provision_args[@]}" "$@"
    deploy -e rehydrate=yes -e deploy_hosts="$instances" "$@"
}

try_as_playbook_or_script() {
    # If you run ``tpaexec xyzzy …``, you end up here to check if there
    # is a matching custom command under architectures/lib/commands or
    # $cluster/commands. If so, we execute it as if it were a built-in
    # command. As a safety measure, we require that custom commands be
    # executed with a cluster directory as the first argument.

    if [[ "${1:-}" && -d $1 && -f $1/config.yml ]]; then
        cd "${cluster:=$1}"
        shift
        for dir in ./commands $TPA_DIR/architectures/lib/commands; do
            playbook=$dir/$command.yml
            script=$dir/$command.sh
            exec=$dir/$command

            if [[ -x $exec ]]; then
                $exec "$@"
                return $?
            elif [[ -f $script ]]; then
                source "$script"
                if [[ $(type -t _tpaexec_command) != function ]]; then
                    error "$script did not define _tpaexec_command"
                fi
                _tpaexec_command "$@"
                return $?
            elif [[ -f $playbook ]]; then
                playbook "$playbook" "$@"
                return $?
            fi
        done
    fi

    # If there's a matching command in architectures/lib and we didn't
    # run it above, a cluster directory must not have been specified
    # (e.g., ``tpaexec test``). Let's try to be helpful.

    C=$TPA_DIR/architectures/lib/commands
    if [[ -x $C/$command || -f $C/$command.sh || -f $C/$command.yml ]]; then
        dir="clusterdir"
        if [[ -f config.yml ]]; then
            dir="."
        fi
        error "tpaexec $command needs a cluster directory (try 'tpaexec $command $dir')"
    fi

    error "unrecognised tpaexec command: $command (try 'tpaexec help')"
}

_tpaexec_info() {
    version
    echo tpaexec="$0"
    echo TPA_DIR="$TPA_DIR"
    echo "PYTHON=$(command -v python) (v$(_python_version), $(_detect_venv))"
    if [[ -d $TPA_VENV ]]; then
        echo TPA_VENV="$TPA_VENV"
    else
        echo TPA_VENV=none
    fi
    if [[ -n "${ANSIBLE_HOME:-}" ]]; then
        echo -n ANSIBLE_HOME="$ANSIBLE_HOME"
        if [[ -d $ANSIBLE_HOME && -x $ANSIBLE_HOME/bin/ansible ]]; then
            echo " (v$(PYTHONPATH=$ANSIBLE_HOME/lib _ansible_version))"
        else
            echo " (invalid)"
        fi
    elif command -v ansible &>/dev/null; then
        echo -n ANSIBLE="$(command -v ansible)"
        echo " (v$(_ansible_version))"
    else
        error "can't find ansible via PATH/ANSIBLE_HOME (did you run 'tpaexec setup'?)"
    fi
}

selftest() {
    _tpaexec_info
    "$TPA_DIR/architectures/lib/selftest.py"
    $ansible --version
    "$ansible"-playbook "$TPA_DIR/architectures/lib/selftest.yml" -e tpa_dir="$TPA_DIR"
}

info() {
    subcommand=${1:-""}
    case "$subcommand" in
        "")
            _tpaexec_info
            ;;
        version)
            version
            ;;
        platforms|architectures)
            echo "Available $subcommand:"
            echo ""

            shopt -s globstar nullglob
            for d in "$TPA_DIR/$subcommand"/**/_metadata;
            do
                (
                    source "$d";
                    if [[ "${STATUS:=experimental}" != "experimental" || ${2:-""} == "-a" ]]; then
                        echo "${NAME:-$(basename "$(dirname "$d")")} [$STATUS]"
                        if [[ ${DESCRIPTION:-""} ]]; then
                            if type fmt &>/dev/null; then
                                echo "    $DESCRIPTION" | fmt -c
                            else
                                echo "    $DESCRIPTION"
                            fi
                        fi
                        echo ""
                    fi
                )
            done
            echo 'Run ``'"tpaexec info $subcommand/<name>"'`` for more information.'
            case "$subcommand" in
                platforms)
                    echo
                    echo 'Run ``tpaexec configure --architecture <name> --platform <name> --help``'
                    echo 'to see available options for an architecture and platform.'
                    ;;
                architectures)
                    echo
                    echo 'Run ``tpaexec configure --architecture <name> --help`` to see available'
                    echo 'options for an architecture.'
                    ;;
            esac
            ;;
        platforms/*|architectures/*)
            doc=$TPA_DIR/$subcommand/README.md
            if [[ ! -f $doc ]]; then
                echo "Sorry, no documentation available for $subcommand"
                echo "Please contact tpa@2ndQuadrant.com for assistance"
                exit 1
            fi
            $PAGER "$doc"
            ;;
        *)
            error "unrecognised info subcommand: $subcommand"
            ;;
    esac
}

help() {
    topic=${1:-""}
    case "$topic" in
        "")
            cat <<TOPICS
Available help topics:
    info
    setup, selftest
    configure, configure-options
    provision, deprovision
    playbook, deploy, test,
    cmd, ping
    rehydrate

Run 'tpaexec help topicname' for more details.
TOPICS
            ;;

        info*)
            cat <<INFO
Available info subcommands:

    tpaexec info
        Displays some information about this installation

    tpaexec info version
        Displays current TPAexec version

    tpaexec info platforms
        Displays available deployment platforms

    tpaexec info architectures
        Displays available deployment architectures

    tpaexec info platforms/xxx
        Displays information about a particular platform

    tpaexec info architectures/xxx
        Displays information about a particular architecture
INFO
            ;;

        setup)
            cat <<SETUP
Command: tpaexec setup

Installs all Python dependencies (Ansible, modules) in an isolated
virtual environment (using the Python 3 builtin ``-m venv``).

The default location is $TPA_VENV

If you use the default location, which we recommend, the venv will
be activated automatically whenever you run tpaexec.

You may optionally specify ``--venv /path/to/venv`` to either use an
existing venv, or create one at the specified location. If you do this,
you must ensure that the venv is activated before you run tpaexec.
SETUP
            ;;

        selftest)
            cat <<SELFTEST
Command: tpaexec selftest

Performs a sanity test on this installation of TPAexec
SELFTEST
            ;;

        configure-options)
            $PAGER "$TPA_DIR/architectures/lib/OPTIONS.md"
            ;;

        *config*)
            cat <<CONFIG
Command: tpaexec configure clustername --architecture archname …

Creates a clustername directory containing config.yml and deploy.yml
according to the selected architecture. After this step, you can run
'tpaexec provision clustername'.

For more information, see:
    tpaexec info architectures
    tpaexec info architectures/<archname>
CONFIG
            ;;

        provision)
            cat <<PROVISION
Command: tpaexec provision clustername [--owner Owner] [--cached] …

Provisions a cluster according to clustername/config.yml

You may specify ``--owner OwnerName`` to override the default cluster
owner (which is the login name of the current user: ${USER:-$(id -u -n)}).

You may specify ``--cached`` to speed up repeated provision runs in
development by relying on cached information and skipping retests of
resources like VPCs and subnets.

Any other arguments will be passed to ansible-playbook unmodified.
PROVISION
            ;;

        command|adhoc|cmd)
            cat <<COMMAND
Command: tpaexec cmd clustername all -m module -a "arguments"

Runs an ansible command in the context of a cluster

Examples:

    # Print the value of an ansible variable
    tpaexec cmd clustername all -m debug -a var=inventory_hostname

    # Install a package
    tpaexec cmd clustername all -sm package -a 'name=pkgname state=latest'

    # Run arbitrary shell commands
    tpaexec cmd clustername host1,host2 -m shell -a 'ps -ef|grep repmgr'

    # Ensure key is present in ~admin/.ssh/authorized_keys
    tpaexec cmd clustername all -m authorized_key -a \\
        "user=admin key=\"{{ lookup('file', 'id_someone.pub') }}\""
COMMAND
            ;;

        ping)
            cat <<PING
Command: tpaexec ping clustername

Runs the ansible ping module against all hosts in a cluster
PING
            ;;

        playbook)
            cat <<PLAYBOOK
Command: tpaexec playbook clustername/playbook.yml
Command: tpaexec playbook clustername /path/to/playbook.yml

Runs a playbook in the context of a particular cluster

Any additional arguments will be passed to ansible-playbook unmodified.
PLAYBOOK
            ;;

        deploy)
            cat <<DEPLOY
Command: tpaexec deploy clustername

Deploys a cluster according to clustername/deploy.yml

Any additional arguments will be passed to ansible-playbook unmodified.
DEPLOY
            ;;

        test)
            cat <<TEST
Command: tpaexec test clustername [testname] [options]

Runs tests for a cluster according to its architecture.

You may specify the name of a test to run as the first argument instead
of the built-in test named 'default'. (Depending on the test, you may
need to provide additional options on the command line.)

The ``tpaexec test clustername test`` command will search for test.yml
in the cluster's tests subdirectory first, then fall back to built-in
tests. You may create new tests (as Ansible playbooks) under the
cluster's tests subdirectory.

To run tests from a different location, you may specify
``--include-tests-from /other/path``.
TEST
            ;;

        deprovision)
            cat <<DEPROVISION
Command: tpaexec deprovision clustername

Completely destroys a clustername and all associated resources
DEPROVISION
            ;;

        rehydrate)
            cat <<REHYDRATE
Command: tpaexec rehydrate clustername instance1[,instance2,…]

Takes a comma-separated list of hostnames and "rehydrates" each host:

1. Ensures that all extra volumes attached to the instance are tagged
   correctly and set to not be deleted on termination of the instance.
2. Terminates the instances and waits for the operation to complete.
3. Provisions replacements for each terminated instance.
4. Redeploys software on the new instances.
REHYDRATE
            ;;

        *)
            echo "Sorry, no help available for $topic"
            echo "Please contact tpa@2ndQuadrant.com for assistance"
            exit 1
            ;;
    esac
}

## Command handling
#
# We may be invoked as "tpaexec command …", or through a symbolic link
# from command → tpaexec (for backwards compatibility).

exec=$(basename "$0")
case "$exec" in
    tpaexec)
        command=${1:?No command specified (try 'tpaexec help')}
        shift
        ;;
    provision|deprovision|deploy|rehydrate)
        command=$exec
        ;;
    *)
        error "unrecognised tpaexec command link: $exec"
        ;;
esac

# We support some command aliases as a convenience.

case "$command" in
    config)
        command=configure
        ;;
    command|adhoc|cmd)
        command=cmd
        ;;
    --version)
        command=version
        ;;
esac

# Some commands take the path to a cluster directory as an argument, and
# we may need to chdir to it beforehand.

case "$command" in
    playbook)
        arg=${1:?No cluster specified}
        shift

        # We accept either the name of a cluster directory (and assume
        # that playbook.yml is somewhere among the remaining arguments)
        # or a path to a playbook within a cluster directory.

        if [[ -d $arg ]]; then
            cluster=$arg
        elif [[ -f $arg ]]; then
            cluster=$(dirname "$arg")
            file=$(basename "$arg")
            set -- "$file" "$@"
        else
            error "argument is neither directory nor file: $arg"
        fi

        cd "$cluster"
        ;;

    cmd|ping|provision|deploy|deprovision|rehydrate)
        cluster=${1:?No cluster specified}
        shift

        if [[ ! -d $cluster ]]; then
            error "cluster directory does not exist: $cluster"
        fi

        cd "$cluster"
        ;;
esac

# If we can find a venv located relative to TPA_DIR, we activate it as a
# convenience.

if [[ -f $TPA_VENV/bin/activate ]]; then
    _activate_venv "$TPA_VENV"
fi

# Now we can look at the command-line arguments and decide which
# function to call.

case "$command" in
    *help)
        help "$*"
        ;;

    info|version|setup|configure|selftest)
        $command "$@"
        ;;

    cmd|ping|provision|deploy|playbook|deprovision|rehydrate)
        time $command "$@"
        ;;

    *)
        try_as_playbook_or_script "$@"
        ;;
esac
