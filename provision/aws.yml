---

# Provision EC2 instances according to a separate configuration file.
#
# The appropriate AWS IAM credentials must be supplied separately, e.g.
# in ~/.boto or in the environment.

- hosts: localhost

  # The configuration comes from an external file, but we derive some
  # sensible defaults for internal use. We must use different variable
  # names to avoid template recursion when the values are overriden.

  vars:
    ec2_key_file: "{{ key_file | default('id_' + cluster_name|lower) }}"
    ec2_key_name: "{{ key_name | default('2Q_' + cluster_name|lower) }}"

  tasks:

    # Make sure we're invoked with «--extra-vars @suitable-config.yml»
    #
    # XXX We assume that the instances are all in different regions, so
    # that we must repeat the VPC/security group/keypair configuration
    # in each region. Some reorganisation will be needed to support
    # multiple instances in the same region.

    - name: Ensure cluster configuration is present
      assert:
        msg: "Please rerun with «--extra-vars @clustername-aws.yml»"
        that:
          - cluster_name is defined and cluster_name != ''
          - instances | length > 0
          - instances | map(attribute='region') | list | unique | length ==
            instances | map(attribute='region') | list | length

    # Set up a VPC in each region with a single public subnet and an
    # internet gateway. A VPC is an isolated network zone comprising
    # multiple subnets, gateways, etc.

    - name: Set up VPCs
      ec2_vpc:
        state: present
        region: "{{ item.region }}"
        cidr_block: "{{ item.subnet }}"
        resource_tags: "{{ cluster_tags }}"
        internet_gateway: yes
        subnets:
          - cidr: "{{ item.subnet }}"
            resource_tags:
              name: "{{ cluster_name }}/{{ item.region }}"
        route_tables:
          - subnets:
              - "{{ item.subnet }}"
            routes:
              - dest: 0.0.0.0/0
                gw: igw
        wait: yes
      with_items: instances
      register: vpcs
      tags: vpcs

    # Set up a security group in each VPC. A security group is a set of
    # firewall rules. We explicitly allow certain incoming traffic; by
    # default, there is an egress rule that allows everything.

    - name: Set up security groups
      ec2_group:
        state: present
        vpc_id: "{{ item.vpc.id }}"
        region: "{{ item.vpc.region }}"
        name: "{{ cluster_name }}/{{ item.vpc.region }}"
        description: "Security group for {{ cluster_name }} in {{ item.vpc.region }}"
        rules:
          - proto: tcp
            from_port: 22
            to_port: 22
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 80
            to_port: 80
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 443
            to_port: 443
            cidr_ip: 0.0.0.0/0
          - proto: tcp
            from_port: 5432
            to_port: 5432
            cidr_ip: 0.0.0.0/0
          - proto: udp
            from_port: 1194
            to_port: 1194
            cidr_ip: 0.0.0.0/0
      with_items: vpcs.results
      register: security_groups
      tags: groups

    # Create an SSH keypair and make sure the public key is stored in
    # each region. This key is used to initially provide SSH access to
    # the EC2 instances we set up next.

    - name: Create a new keypair
      command: ssh-keygen -P "" -f "{{ ec2_key_file }}" -C 2ndQuadrant
        creates="{{ ec2_key_file }}"
      tags: keys
    - name: Set up keypair in each region
      ec2_key:
        state: present
        name: "{{ ec2_key_name }}"
        key_material: "{{ lookup('file', ec2_key_file + '.pub') }}"
        region: "{{ item.region }}"
        wait: yes
      with_items: instances
      tags: keys

    # Create EC2 instances using the VPC subnets and security groups and
    # access key we configured above.

    - name: Set up EC2 instances
      ec2:
        exact_count: 1
        count_tag: "{{ cluster_tags }}"
        image: "{{ item.0.image }}"
        region: "{{ item.0.region }}"
        group_id: "{{ item.2.group_id }}"
        instance_type: "{{ item.0.type }}"
        vpc_subnet_id: "{{ item.1.subnets[0].id }}"
        instance_tags: "{{ cluster_tags | merge(item.0.tags) }}"
        key_name: "{{ ec2_key_name }}"
        assign_public_ip: yes
        volumes: "{{ item.0.volumes }}"
        wait: yes
      with_together:
        - instances
        - vpcs.results
        - security_groups.results
      register: ec2_instances

    # Associate an elastic IP with each instance.

    - name: Associate elastic IPs
      ec2_eip:
        state: present
        region: "{{ item.instances[0].region }}"
        instance_id: "{{ item.instances[0].id }}"
        reuse_existing_ip_allowed: true
      with_items: ec2_instances.results
      when: ec2_instances.changed
      register: eips
